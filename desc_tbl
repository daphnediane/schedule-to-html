#!/usr/bin/perl

use common::sense;
use utf8;
use Text::CSV;
use Date::Parse qw{ str2time };
use POSIX qw{ strftime };
use HTML::Tiny qw{};
use Readonly;

# Global variables
Readonly our $HALF_HOUR => 30 * 60;

our $fname;
our $oname;

our %schedule;
our %rooms;
our %time_region;

our @room_ids;
our @start_times;
our $ofh;

sub splitline {
    my ( $fh ) = @_;
    my $line = $fh->getline;
    return unless defined $line;
    my $full_line = $line;
    my @raw = split m{\t}xms, $line;
    my @res;
    while ( @raw ) {
        my $piece = shift @raw;
        if ( $piece =~ m{ \A " }xms ) {
            my $full = $piece;
            while ( $full
                !~ m{ \A " (?: [^"]++ | (?: "" )++ )* " (?:\n\r?+|\r\n?+)?+ \z }xms
                )
            {
                unless ( @raw ) {
                    chomp $full_line;
                    die "Unable to process: [", $full, "]\nin line: ",
                        $full_line, qq{\n};
                }
                $full .= shift @raw;
            } ## end while ( $full !~ ...)
            $full =~ s{ \A " }{}xms;
            $full =~ s{ (?:\n\r+?|\r\n+?)?+ \z }{}xms;
            $full =~ s{ " \z }{}xms;
            $full =~ s{ "" }{"}xmsg;
            push @res, $full;
        } ## end if ( $piece =~ m{ \A " }xms)
        else {
            push @res, $piece;
        }
    } ## end while ( @raw )
    return \@res;
} ## end sub splitline

sub time_split {
    my ( $time ) = @_;
    return unless defined $time;
    if ( $time =~ s{ \s ([AP]M) \z}{}xms ) {
        return $time, $1;
    }
    else {
        return $time;
    }
} ## end sub time_split

sub add_split {
    my ( $time, $name ) = @_;
    $time_region{ $time }->{ name } = $name;
}

sub add_time {
    my ( $time ) = @_;
    return if $schedule{ $time };
    $schedule{ $time } = 1;
}

sub read_csv_file {
    open my $fh, "<:encoding(utf16)", $fname
        or die qq{Unable to read: $fname\n};

    my $header = splitline( $fh )
        or die "Missing header in: ", $fname, "\n";

    my %ids;

    while ( my $raw = splitline( $fh ) ) {
        last unless defined $raw;
        my %panel;
        foreach my $index ( keys @{ $raw } ) {
            my $header_text = $header->[ $index ];
            my $header_alt  = $header_text;
            $header_alt =~ s{\s+}{_}xmsg;
            $header_alt =~ s{/}{_}xmsg;
            $header_alt =~ s{_+}{_}xmsg;
            my $raw_text = $raw->[ $index ];
            if ( $raw_text =~ m{\s} ) {
                $raw_text =~ s{\A \s*}{}xms;
                $raw_text =~ s{\s* \z}{}xms;
            }
            $raw_text = undef if $raw_text eq q{};
            $panel{ $header_text } = $raw_text;
            $panel{ $header_alt }  = $raw_text;
        } ## end foreach my $index ( keys @{...})
        next unless defined $panel{ Start_Time };
        next unless $panel{ Name } =~ m{\S}xms;
        my $start = str2time( $panel{ Start_Time } );
        my $end
            = defined $panel{ End_Time }
            ? str2time( $panel{ End_Time } )
            : $start;
        my $start_12 = strftime q{%I:%M %p}, localtime $start;
        my $end_12   = strftime q{%I:%M %p}, localtime $end;
        my $idx      = $panel{ Room_Idx };
        my $id       = $panel{ Uniq_ID };
        my $kind = $id // q{Unknown};
        $kind =~ s{\d+[[:alpha:]]?\z}{}xms;

        if ( $ids{ $id } ) {
            my $indx = ++$ids{ $id };
            $id .= q{Dup} . $indx;
        }
        else {
            $ids{ $id } = 1;
        }

        $panel{ Start_Tm }   = $start;
        $panel{ End_Tm }     = $end;
        $panel{ Start_12 }   = $start_12;
        $panel{ End_12 }     = $end_12;
        $panel{ Table_Rows } = 0;
        $panel{ Class }      = q{Type} . $kind;
        $panel{ HRef }       = $id;

        if ( $panel{ Room } eq q{SPLIT} ) {
            add_split $start, $panel{ Name };
            next;
        }

        next if $idx eq q{};
        next if $idx > 90;

        add_time $start;
        add_time $end;

        my $room = $rooms{ $idx } //= {};
        $room->{ $idx } = $idx;
        $room->{ name }  //= $panel{ Room };
        $room->{ hotel } //= $panel{ Real_Room };
        $room->{ start }->{ $start } = \%panel;
        $room->{ end }->{ $end }     = \%panel;
    } ## end while ( my $raw = splitline...)

    $fh->close
        or die qq{Unable to close $fname: $!\n};

    @room_ids    = sort { $a <=> $b } keys %rooms;
    @start_times = sort { $a <=> $b } keys %schedule;

} ## end sub read_csv_file

sub make_time_ranges {
    my %time_points = map { $_ => 1 } ( keys %time_region, keys %schedule );
    my @time_points = sort { $a <=> $b } keys %time_points;

    my $active_range;
    my %active_panels;
    my $last_time;

    my $process_time = sub {
        my ( $time ) = @_;

        foreach my $room_idx ( @room_ids ) {
            my $room = $rooms{ $room_idx };
            if ( exists $active_panels{ $room_idx } ) {
                my $panel     = $active_panels{ $room_idx };
                my $panel_end = $panel->{ end };
                if ( $panel_end >= $time ) {
                    delete $active_panels{ $room_idx };
                }
            } ## end if ( exists $active_panels...)
            if ( defined( my $new_panel = $room->{ start }->{ $time } ) ) {
                $new_panel->{ Table_Start } = $time;
                $active_panels{ $room_idx } = $new_panel;
            }
        } ## end foreach my $room_idx ( @room_ids)
        foreach my $panel ( values %active_panels ) {
            ++$panel->{ Table_Rows };
        }
        $active_range->{ row }->{ $time } = { %active_panels };
        $last_time = $time;
        return;
    };

    my $process_half_hours = sub {
        my ( $split_time ) = @_;
        return unless defined $last_time;
        for (
            my $time = $last_time + $HALF_HOUR ;
            $time < $split_time ;
            $time += $HALF_HOUR
            )
        {
            $process_time->( $time );
        } ## end for ( my $time = $last_time...)
        return;
    };

    foreach my $split_time ( @time_points ) {
        if ( !defined $active_range ) {
            $time_region{ $split_time }->{ name } //= q{Before Convention};
        }
        my $next_range = $time_region{ $split_time };

        if ( defined $next_range ) {
            if ( %active_panels ) {
                $process_half_hours->( $split_time );
            }
            foreach my $room_idx ( keys %active_panels ) {
                my %panel = %{ $active_panels{ $room_idx } };
                $panel{ across_region }     = 1;
                $panel{ Table_Rows }        = 0;
                $panel{ Table_Start }       = $split_time;
                $active_panels{ $room_idx } = \%panel;
            } ## end foreach my $room_idx ( keys...)
            $active_range = $next_range;
            undef $last_time;
        } ## end if ( defined $next_range)
        elsif ( %active_panels ) {
            $process_half_hours->( $split_time );
        }
        $process_time->( $split_time );
    } ## end foreach my $split_time ( @time_points)
} ## end sub make_time_ranges

sub dump_tables {
    my %time_points = map { $_ => 1 } ( keys %time_region );

    my $ofh;
    if ( $oname eq q{-} ) {
        $ofh = \*STDOUT;
    }
    else {
        open $ofh, ">:encoding(utf8)", $oname
            or die qq{Unable to write: $oname\n};
    }

    foreach my $region_time ( sort { $a <=> $b } keys %time_region ) {
        my $region = $time_region{ $region_time };
        say { $ofh } $region->{ name };
    }

    if ( $oname ne q{-} ) {
        $ofh->close
            or die qq{Unable to close $oname: $!\n};
    }

} ## end sub dump_tables

sub main {
    ( $fname, $oname ) = @_;
    $oname //= q{-};

    read_csv_file( $fname );

    make_time_ranges;

    dump_tables;
} ## end sub main

main( @ARGV );

1;

__END__

# Partition panels
foreach my $time ( @start_or_split ) {

}

# Determine number of rows needed pass 1
foreach my $room ( values %rooms ) {
    my $active;
    my $starts = $room->{ start };
    my $ends   = $room->{ end };
    next unless ref $starts;

    foreach my $time ( @start_times ) {
        undef $active if $ends->{ $time };
        my $rec = $starts->{ $time };
        $active = $rec if defined $rec;
        next unless defined $active;
        ++$active->{ Table_Rows };
    } ## end foreach my $time ( @start_times)
} ## end foreach my $room ( values %rooms)

my $h = HTML::Tiny->new( mode => q{html} );

my $ofh;
if ( $oname eq q{-} ) {
    $ofh = \*STDOUT;
}
else {
    open $ofh, ">:encoding(utf8)", $oname
        or die qq{Unable to write: $oname\n};
}

say { $ofh } $h->open( qw{ table }, { class => q{schedule} } );

say { $ofh } qq{\t}, $h->open( qw{ thead } );
say { $ofh } qq{\t}, $h->open( qw{ tr }, { class => q{schedheadrow} } );
say { $ofh } qq{\t\t},
    $h->th( { class => q{schedhead scheddaycolumn} }, q{Day} );
say { $ofh } qq{\t\t},
    $h->th( { class => q{schedhead schedtimecolumn} }, q{Time} );
foreach my $idx ( @room_ids ) {
    say { $ofh } qq{\t\t},
        $h->th(
        { class => q{schedhead schedloccolumn roomloc} },
        $rooms{ $idx }->{ hotel } . q{<br/>} . $rooms{ $idx }->{ name }
        );
} ## end foreach my $idx ( @room_ids)
say { $ofh } qq{\t}, $h->close( qw{ tr } );
say { $ofh } qq{\t}, $h->close( qw{ thead } );

my $active_day;

my @desc;

say { $ofh } qq{\t}, $h->open( qw{ tbody } );
foreach my $time ( @start_times ) {
    my @ltime = localtime $time;
    my ( $sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst )
        = @ltime;

    say { $ofh } qq{\t}, $h->open( qw{ tr }, { class => q{schedtimerow} } );

    if ( !defined $active_day || $active_day != $yday ) {
        $active_day = $yday;
        say { $ofh } qq{\t\t},
            $h->th(
            {   class   => q{schedday scheddaycolumn},
                rowspan => $day_rows{ $yday } // 1
            },
            strftime q{%A},
            @ltime
            );
    } ## end if ( !defined $active_day...)
    else {
        say { $ofh } qq{\t\t<!--Day-->};
    }
    say { $ofh } qq{\t\t},
        $h->th(
        { class => q{schedtime schedtimecolumn} },
        strftime q{%I:%M %p}, @ltime
        );

    my @slot;

    foreach my $idx ( @room_ids ) {
        my $room = $rooms{ $idx };

        if ( $room->{ end }->{ $time } ) {
            delete $room->{ active };
        }

        my $rec = $room->{ start }->{ $time };
        print { $ofh } qq{\t\t<!--}, $room->{ name };
        if ( defined $rec ) {
            $room->{ active } = $rec;
            my $difficulty = $rec->{ Difficulty };
            my $tokens     = $rec->{ Tokens };

            my @classes = ( q{}, $rec->{ Class } );
            if ( $difficulty =~ m{\A\d+\z}xms ) {
                push @classes, q{Difficulty} . $difficulty;
            }
            if ( $tokens eq q{0} ) {
                undef $tokens;
            }
            if ( defined $tokens ) {
                push @classes, q{NeedTokens};
                $tokens =~ s{\A\s*}{}xms;
                $tokens =~ s{\s*\z}{}xms;
                $tokens = q{TBD} unless $tokens =~ m{\A\d+\z}xms;
            } ## end if ( defined $tokens )

            say { $ofh } q{-->},
                $h->open(
                q{td},
                {   id      => $rec->{ HRef } . q{Grid},
                    rowspan => $rec->{ Table_Rows },
                    class   => (
                        join q{ }, qw{ schedloccolumn },
                        map { q{panel} . $_ } @classes
                    )
                }
                );
            say { $ofh } qq{\t\t\t},
                $h->div( { class => q{panelid} }, $rec->{ Uniq_ID } );
            say { $ofh } qq{\t\t\t},
                $h->open( q{a}, { href => q{#} . $rec->{ HRef } } );
            say { $ofh } qq{\t\t\t\t},
                $h->span( { class => q{panelname} }, $rec->{ Name } );
            if ( defined $tokens ) {
                say { $ofh } qq{\t\t\t\t},
                    $h->div(
                    { class => q{paneltokens paneltokens} . $tokens },
                    q{Tokens: } . $tokens
                    );
            } ## end if ( defined $tokens )

            my $panelist = $rec->{ Panelist };
            if ( $panelist =~ m{\S}xms ) {
                say { $ofh } qq{\t\t\t\t},
                    $h->span( { class => q{panelist} }, $rec->{ Panelist } );
            }
            say { $ofh } qq{\t\t\t}, $h->close( q{a} );
            say { $ofh } qq{\t\t},   $h->close( q{td} );

            push @slot,
                qq{\t\t\t}
                . $h->open(
                q{li},
                {   id    => $rec->{ HRef },
                    class => join q{ }, map { q{desc} . $_ } @classes
                }
                );
            push @slot,
                qq{\t\t\t\t}
                . $h->div(
                { class => q{descid} },
                $rec->{ Uniq_ID }
                );
            push @slot,
                qq{\t\t\t\t}
                . $h->a(
                {   href  => q{#} . $rec->{ HRef } . q{Grid},
                    class => q{descname}
                },
                $rec->{ Name }
                );
            if ( defined $tokens ) {
                push @slot,
                    qq{\t\t\t\t}
                    . $h->div(
                    { class => q{descTokens descTokens} . $tokens },
                    q{Required tokens: } . $tokens
                    );
            } ## end if ( defined $tokens )

            push @slot,
                qq{\t\t\t\t}
                . $h->p(
                { class => q{descroom} },
                $room->{ hotel }
                );
            if ( $panelist =~ m{\S}xms ) {
                push @slot,
                    qq{\t\t\t\t}
                    . $h->p(
                    { class => q{descpanelist} },
                    $rec->{ Panelist }
                    );
            } ## end if ( $panelist =~ m{\S}xms)
            push @slot, qq{\t\t\t\t}
                . $h->p( { class => q{descbody} }, $rec->{ Description } );

            if ( defined $rec->{ Note } ) {
                push @slot,
                    qq{\t\t\t\t}
                    . $h->p(
                    { class => q{descnote} },
                    $h->i( $rec->{ Note } )
                    );
            } ## end if ( defined $rec->{ Note...})

            if ( $difficulty =~ m{\A\d+\z}xms ) {
                push @slot,
                    qq{\t\t\t\t}
                    . $h->p(
                    {   class => q{descDifficulty descDifficulty}
                            . $difficulty
                    },
                    q{Difficulty level: } . $difficulty
                    );
            } ## end if ( $difficulty =~ m{\A\d+\z}xms)

            push @slot, qq{\t\t\t} . $h->close( q{li} );
        } ## end if ( defined $rec )
        elsif ( defined $room->{ active } ) {
            $rec = $room->{ active };

            say { $ofh } q{ }, $rec->{ Uniq_ID }, q{ continued-->};
        }
        else {
            say { $ofh } q{-->}, $h->td( { class => q{empty} } );
        }
    } ## end foreach my $idx ( @room_ids)

    if ( @slot ) {
        push @desc,
              qq{\t}
            . $h->open( q{li}, { class => q{desctime} } )
            . $h->entity_encode( strftime q{%A %I:%M %p}, @ltime );
        push @desc, qq{\t\t} . $h->open( q{ul} );
        chomp @slot;
        push @desc, @slot;
        push @desc, qq{\t\t} . $h->close( q{ul} );
        push @desc, qq{\t} . $h->close( q{li} );
    } ## end if ( @slot )

    say { $ofh } qq{\t}, $h->close( qw{ tr } );
} ## end foreach my $time ( @start_times)

say { $ofh } qq{\t}, $h->close( qw{ tbody } );
say { $ofh } $h->close( qw{ table } );

if ( @desc ) {
    say { $ofh } join qq{\n},
        $h->open( q{ul}, { class => q{descriptions} } ), @desc,
        $h->close( q{ul} );
}

if ( $oname ne q{-} ) {
    $ofh->close
        or die qq{Unable to close $oname: $!\n};
}

1;
