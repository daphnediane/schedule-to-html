#!/usr/bin/perl

use common::sense;
use Carp qw{verbose};
use Date::Parse qw{ str2time };
use English qw( -no_match_vars );
use File::Slurp qw{read_file};
use File::Spec;
use Getopt::Long qw{GetOptionsFromArray};
use HTML::Tiny qw{};
use POSIX qw{ strftime };
use Readonly;
use Spreadsheet::ParseXLSX;
use strict;
use Text::CSV;
use utf8;

# Global variables
Readonly our $SEC_PER_MIN   => 60;
Readonly our $MIN_PER_HOUR  => 60;
Readonly our $HOUR_PER_DAY  => 24;
Readonly our $DAYS_PER_WEEK => 7;

Readonly our $HALF_HOUR_IN_SEC => 30 * 60;

Readonly our $LOCALTIME_HOUR => 1;
Readonly our $LOCALTIME_MIN  => 2;
Readonly our $LOCALTIME_DAY  => 6;

Readonly our $CAFE                => q{Café};
Readonly our $ROOM_FIRST_HIDE_IDX => 100;

# Panel fields
Readonly our $TABLE_DESCRIPTION   => q{Description};
Readonly our $TABLE_DURATION      => q{Duration};
Readonly our $TABLE_DIFFICULTY    => q{Difficulty};
Readonly our $TABLE_END_TIME      => q{End_Time};
Readonly our $TABLE_FULL          => q{Full};
Readonly our $TABLE_HOTEL_ROOM    => q{Real_Room};
Readonly our $TABLE_KIND          => q{Kind};
Readonly our $TABLE_NOTE          => q{Note};
Readonly our $TABLE_PANEL_NAME    => q{Name};
Readonly our $TABLE_PANELIST_ALT  => q{Alt_Panelist};
Readonly our $TABLE_PANELIST_HIDE => q{Hide_Panelist};
Readonly our $TABLE_ROOM_INDEX    => q{Room_Idx};
Readonly our $TABLE_ROOM_NAME     => q{Room};
Readonly our $TABLE_START_TIME    => q{Start_Time};
Readonly our $TABLE_TOKENS        => q{Tokens};
Readonly our $TABLE_UNIQUE_ID     => q{Uniq_ID};

# Custom fields
Readonly our $FIELD_ACTIVE_ROOMS            => q{*ROOMS};
Readonly our $FIELD_BY_REGION               => q{*BY_REGION};
Readonly our $FIELD_BY_ROW_SECONDS          => q{*BY_SECONDS};
Readonly our $FIELD_CAFE                    => q{*CAFE};
Readonly our $FIELD_CSS_HREF                => q{*HREF};
Readonly our $FIELD_CSS_SUBCLASSES          => q{*CLASSES};
Readonly our $FIELD_DAY_BEING_OUTPUT        => q{*ACTIVEDAY};
Readonly our $FIELD_END_TIME_SECONDS        => q{*END_SEC};
Readonly our $FIELD_PANELIST_BUSY_ELSEWHERE => q{*BUSY_ELSEWHERE};
Readonly our $FIELD_PANELIST_MAP            => q{*PANELIST_MAP};
Readonly our $FIELD_PANELIST_LISTED         => q{*LISTED_PANELIST};
Readonly our $FIELD_LAST_TIME_OUTPUT        => q{*LASTTIME};
Readonly our $FIELD_NEXT_PANEL              => q{*NEXT};
Readonly our $FIELD_ALL_PANELIST            => q{*PANELIST};
Readonly our $FIELD_REGION_NAME             => q{*NAME};
Readonly our $FIELD_ROOM_INFO               => q{*ROOM_INFO};
Readonly our $FIELD_ROOM_NAME               => q{*NAME};
Readonly our $FIELD_START_TIME_SECONDS      => q{*START_SEC};
Readonly our $FIELD_TABLE_ROWS              => q{*NUM_ROWS};

# HTML Elements
Readonly our $HTML_ANCHOR     => q{a};
Readonly our $HTML_BODY       => q{body};
Readonly our $HTML_COLGROUP   => q{colgroup};
Readonly our $HTML_DIV        => q{div};
Readonly our $HTML_HEAD       => q{head};
Readonly our $HTML_HTML       => q{html};
Readonly our $HTML_STYLE      => q{style};
Readonly our $HTML_TABLE      => q{table};
Readonly our $HTML_TABLE_BODY => q{tbody};
Readonly our $HTML_TABLE_DATA => q{td};
Readonly our $HTML_TABLE_FOOT => q{tfoot};
Readonly our $HTML_TABLE_HEAD => q{thead};
Readonly our $HTML_TABLE_ROW  => q{tr};

# HTML Anchors
Readonly our $ANCHOR_FMT_GRID => q{%sGrid};

# CSS Classes
Readonly our $CLASS_DESC_FMT_SUBCLASS        => q{desc%s};
Readonly our $CLASS_DESC_PANEL_ROW           => q{descPanelRow};
Readonly our $CLASS_DESC_SECTION             => q{descriptions};
Readonly our $CLASS_DESC_TIME_COLUMN         => q{descTimeSlotColumn};
Readonly our $CLASS_DESC_TIME_HEADER         => q{descTimeSlotRowHeader};
Readonly our $CLASS_DESC_TIME_SLOT           => q{descTimeSlot};
Readonly our $CLASS_DESC_TIME_TABLE          => q{descTimeSlotTable};
Readonly our $CLASS_DESC_TYPE_COLUMN         => q{descTypeColumn};
Readonly our $CLASS_DESC_TYPE_HEADER         => q{descTypeHeader};
Readonly our $CLASS_DESC_TYPE_TABLE          => q{descTypeTable};
Readonly our $CLASS_GRID_CELL_DAY            => q{schedWeekDay};
Readonly our $CLASS_GRID_CELL_EMPTY          => q{schedRoomEmpty};
Readonly our $CLASS_GRID_CELL_FMT_SUBCLASS   => q{panel%s};
Readonly our $CLASS_GRID_CELL_FOCUS          => q{roomFocus};
Readonly our $CLASS_GRID_CELL_HEADER         => q{schedHeader};
Readonly our $CLASS_GRID_CELL_PANELIST_BUSY  => q{schedTimeSlotGuestBusy};
Readonly our $CLASS_GRID_CELL_ROOM_NAME      => q{schedRoomName};
Readonly our $CLASS_GRID_CELL_TIME_SLOT      => q{schedTimeSlot};
Readonly our $CLASS_GRID_CELL_UNFOCUS        => q{roomUnfocus};
Readonly our $CLASS_GRID_COLUMN_DAY          => q{schedColumnDay};
Readonly our $CLASS_GRID_COLUMN_FMT_ROOM_IDX => q{schedColumnRoom%s};
Readonly our $CLASS_GRID_COLUMN_ROOM         => q{schedColumnsRoom};
Readonly our $CLASS_GRID_COLUMN_TIME         => q{schedColumnTime};
Readonly our $CLASS_GRID_ROW_HEADER          => q{schedRowHeaders};
Readonly our $CLASS_GRID_ROW_PANELIST_BUSY   => q{schedRowTimeSlotGuestBusy};
Readonly our $CLASS_GRID_ROW_TIME_SLOT       => q{schedRowTimeSlot};
Readonly our $CLASS_GRID_TABLE               => q{schedule};
Readonly our $CLASS_KIOSK_BAR                => q{top_bar};
Readonly our $CLASS_KIOSK_COLUMN_CURRENT     => q{descColCurrent};
Readonly our $CLASS_KIOSK_COLUMN_FUTURE      => q{descColNext};
Readonly our $CLASS_KIOSK_COLUMN_ROOM        => q{descColRoom};
Readonly our $CLASS_KIOSK_DESC_BODY          => q{descBody};
Readonly our $CLASS_KIOSK_DESC_CELL_CURRENT  => q{descCurrent};
Readonly our $CLASS_KIOSK_DESC_CELL_EMPTY    => q{descEmpty};
Readonly our $CLASS_KIOSK_DESC_CELL_FUTURE   => q{descNext};
Readonly our $CLASS_KIOSK_DESC_CELL_HEADER   => q{descHeader};
Readonly our $CLASS_KIOSK_DESC_CELL_ROOM     => q{descRoom};
Readonly our $CLASS_KIOSK_DESC_HEAD          => q{descHead};
Readonly our $CLASS_KIOSK_DESC_ROW_HEADERS   => q{descRowHeader};
Readonly our $CLASS_KIOSK_DESC_ROW_ROOM      => q{descRowRoom};
Readonly our $CLASS_KIOSK_DESCRIPTIONS       => q{bottom_half};
Readonly our $CLASS_KIOSK_GRID_HEADERS       => q{table_headers};
Readonly our $CLASS_KIOSK_GRID_ROWS          => q{table_rows};
Readonly our $CLASS_KIOSK_HIDDEN             => q{inactiveDesc};
Readonly our $CLASS_KIOSK_LOGO               => q{logo};
Readonly our $CLASS_KIOSK_TIME               => q{time};

# CSS Subclasses
Readonly our $SUBCLASS_BUSY_PANEL        => q{ConflictGuest};
Readonly our $SUBCLASS_FMT_DIFFICULTY    => q{Difficulty%s};
Readonly our $SUBCLASS_FMT_TYPE          => q{Type%s};
Readonly our $SUBCLASS_FULL              => q{Full};
Readonly our $SUBCLASS_GUEST_PANEL       => q{SelectedGuest};
Readonly our $SUBCLASS_NEED_TOKENS       => q{NeedTokens};
Readonly our $SUBCLASS_PIECE_DESCRIPTION => q{Description};
Readonly our $SUBCLASS_PIECE_DIFFICULTY  => q{Difficulty};
Readonly our $SUBCLASS_PIECE_FMT_TOKENS  => q{Tokens%s};
Readonly our $SUBCLASS_PIECE_FULL        => q{FullLabel};
Readonly our $SUBCLASS_PIECE_ID          => q{ID};
Readonly our $SUBCLASS_PIECE_NAME        => q{Name};
Readonly our $SUBCLASS_PIECE_NOTE        => q{Note};
Readonly our $SUBCLASS_PIECE_PANELIST    => q{Panelist};
Readonly our $SUBCLASS_PIECE_ROOM        => q{RoomName};
Readonly our $SUBCLASS_PIECE_START       => q{Start};
Readonly our $SUBCLASS_PIECE_TOKENS      => q{Tokens};

# Grid headers
Readonly our $HEADING_DAY  => q{Day};
Readonly our $HEADING_TIME => q{Time};

# File handles
Readonly our $HANDLE_TYPE           => q{type};
Readonly our $HANDLE_NAME           => q{name};
Readonly our $HANDLE_PARSER         => q{parser};
Readonly our $HANDLE_WORKBOOK       => q{workbook};
Readonly our $HANDLE_SCHEDULE_SHEET => q{sched_sheet};
Readonly our $HANDLE_COLUMN_RANGE   => q{col_range};
Readonly our $HANDLE_NEXT_ROW       => q{row_next};
Readonly our $HANDLE_LAST_ROW       => q{row_last};
Readonly our $HANDLE_FILE_HANDLE    => q{fh};

Readonly our $FILE_EXCEL => q{excel};
Readonly our $FILE_TEXT  => q{text};

# Formatting strings
Readonly our $FMT_DAY  => q{%A};
Readonly our $FMT_TIME => q{%I:%M %p};

# Panelist headers
Readonly our $PANELIST_NAME          => q{name};
Readonly our $PANELIST_RANK          => q{rank};
Readonly our $PANELIST_INDEX         => q{index};
Readonly our $PANELIST_SUBINDEX      => q{subindex};
Readonly our $PANELIST_OTHER         => q{other};
Readonly our $PANELIST_IS_META       => q{meta};
Readonly our $PANELIST_IS_INDIVIDUAL => q{individual};
Readonly our $PANELIST_IS_GROUP      => q{is_group};
Readonly our $PANELIST_GROUP         => q{group};
Readonly our $GROUP_MEMBERS          => q{members};

Readonly our $PANELIST_RANK_GUEST         => 0;
Readonly our $PANELIST_RANK_STAFF         => 1;
Readonly our $PANELIST_RANK_INVITED_GUEST => 2;
Readonly our $PANELIST_RANK_FAN_PANELIST  => 3;
Readonly our $PREFIX_TO_PANELIST_RANK     => {
    g => $PANELIST_RANK_GUEST,
    s => $PANELIST_RANK_STAFF,
    i => $PANELIST_RANK_INVITED_GUEST,
    p => $PANELIST_RANK_FAN_PANELIST,
};

Readonly our $GUEST_ANY      => q{All Guests};
Readonly our $GUEST_ANY_INFO => {
    $PANELIST_NAME     => $GUEST_ANY,
    $PANELIST_RANK     => $PANELIST_RANK_GUEST,
    $PANELIST_INDEX    => -1,
    $PANELIST_SUBINDEX => 0,
    $PANELIST_IS_META  => 1,
};

# Grid filter
Readonly our $FILTER_SPLIT_TIMESTAMP => q{timestamp};
Readonly our $FILTER_PANELIST        => q{panelist};
Readonly our $FILTER_ROOM            => q{room};
Readonly our $FILTER_OUTPUT_NAME     => q{subname};
Readonly our $DEFAULT_FILTER         => {
    $FILTER_OUTPUT_NAME => [],
};

my @option_css_styles;
my $option_desc_at_end;
my $option_embed_css;
my $option_file_per_day;
my $option_file_per_guest;
my $option_file_per_panelist;
my $option_file_per_room;
my @option_rooms;
my $option_hide_unused_rooms;
my $option_input_file;
my $option_is_postcard;
my $option_just_panelist;
my $option_kiosk_mode;
my $option_output;
my $option_show_day_column;
my $option_show_descriptions;
my $option_show_grid;
my $option_split_per_day;
my $option_title;
my $option_unified_grid;

my %panelist_info = (
    $GUEST_ANY => $GUEST_ANY_INFO,
);

my %schedule;
my %rooms;
my %panels_by_start;
my %time_region;
my $earliest;

my @all_room_ids;
my @start_times;
my $output_file_handle;
my $output_file_name;
my $level = 0;
my $h     = HTML::Tiny->new( mode => q{html} );

sub open_xlsx_file {
    my ( $fname ) = @_;

    my $sheet_num = 0;
    if ( $fname =~ s{:(\d+)\z}{}xms ) {
        $sheet_num = $1;
    }

    my $p = Spreadsheet::ParseXLSX->new;
    my $w = $p->parse( $fname )
        or die qq{Unable to read: ${fname}\n};
    my $ws      = $w->worksheet( $sheet_num );
    my @columns = $ws->col_range();
    my @rows    = $ws->row_range();

    return {
        $HANDLE_TYPE           => $FILE_EXCEL,
        $HANDLE_NAME           => $fname,
        $HANDLE_PARSER         => $p,
        $HANDLE_WORKBOOK       => $w,
        $HANDLE_SCHEDULE_SHEET => $ws,
        $HANDLE_COLUMN_RANGE   => \@columns,
        $HANDLE_NEXT_ROW       => $rows[ 0 ],
        $HANDLE_LAST_ROW       => $rows[ 1 ]
    };
} ## end sub open_xlsx_file

sub open_text_file {
    my ( $fname ) = @_;

    open my $fh, q{<:encoding(utf16)}, $fname
        or die qq{Unable to read: ${fname}\n};

    return {
        $HANDLE_TYPE        => $FILE_TEXT,
        $HANDLE_NAME        => $fname,
        $HANDLE_FILE_HANDLE => $fh,
    };
} ## end sub open_text_file

sub open_file {
    my ( $fname ) = @_;

    if ( $fname =~ m{[.]xlsx(?: : \d+ )?\z}xmsg ) {
        return open_xlsx_file( $fname );
    }

    return open_text_file( $fname );
} ## end sub open_file

sub close_excel {
    return;
}

sub close_text {
    my ( $handle ) = @_;

    my $name = $handle->{ $HANDLE_NAME };
    $handle->{ $HANDLE_FILE_HANDLE }->close
        or die qq{Unable to close ${name}: ${ERRNO}\n};

    return;
} ## end sub close_text

sub close_file {
    my ( $handle ) = @_;

    if ( $handle->{ $HANDLE_TYPE } eq $FILE_EXCEL ) {
        return close_excel( $handle );
    }

    if ( $handle->{ $HANDLE_TYPE } eq $FILE_TEXT ) {
        return close_text( $handle );
    }

    die q{Unable to close: }, $handle->{ $HANDLE_TYPE }, q{: },
        $handle->{ $HANDLE_NAME },
        qq{\n};
} ## end sub close_file

sub splitline_excel {
    my ( $handle ) = @_;
    return if $handle->{ $HANDLE_NEXT_ROW } > $handle->{ $HANDLE_LAST_ROW };

    my $row = $handle->{ $HANDLE_NEXT_ROW };
    $handle->{ $HANDLE_NEXT_ROW } = 1 + $row;
    my $first_col = $handle->{ $HANDLE_COLUMN_RANGE }->[ 0 ];
    my $last_col  = $handle->{ $HANDLE_COLUMN_RANGE }->[ 1 ];
    my $ws        = $handle->{ $HANDLE_SCHEDULE_SHEET };
    my @res;
    foreach my $col ( $first_col .. $last_col ) {
        my $cell  = $ws->get_cell( $row, $col );
        my $value = defined $cell ? $cell->value() : undef;
        undef $value unless $value =~ m{\S}xms;
        push @res, $value;
    } ## end foreach my $col ( $first_col...)
    return \@res;
} ## end sub splitline_excel

sub splitline_text {
    my ( $fh ) = @_;
    my $line = $fh->getline;
    return unless defined $line;
    my $full_line = $line;
    my @raw       = split m{\t}xms, $line;
    my @res;
    while ( @raw ) {
        my $piece = shift @raw;
        if ( $piece =~ m{ \A " }xms ) {
            my $full = $piece;
            while ( $full
                !~ m{ \A " (?: [^"]++ | (?: "" )++ )* " (?:\n\r?+|\r\n?+)?+ \z }xms
                )
            {
                unless ( @raw ) {
                    chomp $full_line;
                    die
                        qq{Unable to process: [${full}]\nin line: ${full_line}\n};
                }
                $full .= shift @raw;
            } ## end while ( $full !~ ...)
            $full =~ s{ \A " }{}xms;
            $full =~ s{ (?:\n\r?+|\r\n?+)?+ \z }{}xms;
            $full =~ s{ " \z }{}xms;
            $full =~ s{ "" }{"}xmsg;
            push @res, $full;
        } ## end if ( $piece =~ m{ \A " }xms)
        else {
            push @res, $piece;
        }
    } ## end while ( @raw )
    return \@res;
} ## end sub splitline_text

sub splitline {
    my ( $handle ) = @_;

    if ( $handle->{ $HANDLE_TYPE } eq $FILE_EXCEL ) {
        return splitline_excel( $handle );
    }

    if ( $handle->{ $HANDLE_TYPE } eq $FILE_TEXT ) {
        return splitline_text( $handle->{ $HANDLE_FILE_HANDLE } );
    }

    die q{Unable to read: }, $handle->{ $HANDLE_TYPE }, q{: },
        $handle->{ $HANDLE_NAME },
        qq{\n};
} ## end sub splitline

sub time_split {
    my ( $time ) = @_;
    return unless defined $time;
    if ( $time =~ s{ \s ([AP]M) \z}{}xms ) {
        return $time, $1;
    }
    else {
        return $time;
    }
} ## end sub time_split

sub add_split {
    my ( $time, $name ) = @_;
    my $region = $time_region{ $time } //= {};
    if ( $option_split_per_day ) {
        $name =~ s{\s.*}{}xms;
    }
    $region->{ $FIELD_REGION_NAME } //= $name;
    $region->{ $FIELD_START_TIME_SECONDS } = $time;
    return $region;
} ## end sub add_split

sub add_time {
    my ( $time ) = @_;
    return if $schedule{ $time };
    $earliest //= $time;
    $earliest = $time if $time < $earliest;
    $schedule{ $time } = 1;
    return;
} ## end sub add_time

sub santize_hdr {
    my ( $hdr ) = @_;
    $hdr =~ s{\s+}{_}xmsg;
    $hdr =~ s{/}{_}xmsg;
    $hdr =~ s{[().,]}{_}xmsg;
    $hdr =~ s{_+}{_}xmsg;
    $hdr =~ s{\A_}{}xmsg;
    $hdr =~ s{_\z}{}xmsg;
    return $hdr;
} ## end sub santize_hdr

sub lookup_panelist {
    my ( $name_with_group, $index, $rank ) = @_;
    $name_with_group //= q{};

    if ( $name_with_group =~ m{\A\w:}xms ) {
        my ( $rank_name, $remain ) = split m{:}xms,
            $name_with_group, 2;
        $rank            = $PREFIX_TO_PANELIST_RANK->{ lc $rank_name };
        $name_with_group = $remain;
    } ## end if ( $name_with_group ...)
    return if $name_with_group eq q{};
    return if $name_with_group eq q{*};
    return unless defined $rank;

    my ( $panelist, $group ) = split m{=}xms, $name_with_group, 2;

    my $sub_index = 0;
    if ( ref $index ) {
        ( $index, $sub_index ) = @{ $index };
    }

    if ( lc $panelist eq q{other} ) {
        $panelist = $rank . q{:Other};

        return $panelist_info{ $panelist } //= {
            $PANELIST_NAME          => $panelist,
            $PANELIST_RANK          => $rank,
            $PANELIST_INDEX         => $index,
            $PANELIST_SUBINDEX      => $sub_index,
            $PANELIST_IS_INDIVIDUAL => 1,
            $PANELIST_OTHER         => 1
        };
    } ## end if ( lc $panelist eq q{other})

    my $info = $panelist_info{ $panelist } //= {
        $PANELIST_NAME          => $panelist,
        $PANELIST_RANK          => $rank,
        $PANELIST_INDEX         => $index,
        $PANELIST_SUBINDEX      => $sub_index,
        $PANELIST_IS_INDIVIDUAL => 1
    };
    if ( $info->{ $PANELIST_RANK } > $rank ) {
        $info->{ $PANELIST_RANK } = $rank;
    }

    if ( $group ) {

        my $ginfo = $panelist_info{ $group } //= {
            $PANELIST_NAME     => $group,
            $PANELIST_RANK     => $rank,
            $PANELIST_INDEX    => $index,
            $PANELIST_SUBINDEX => $sub_index,
            $PANELIST_IS_GROUP => 1
        };
        $info->{ $PANELIST_GROUP } = $ginfo;
        if ( $ginfo->{ $PANELIST_RANK } > $rank ) {
            $ginfo->{ $PANELIST_RANK } = $rank;
        }
        $ginfo->{ $GROUP_MEMBERS }->{ $panelist } = 1;
    } ## end if ( $group )

    return $info;
} ## end sub lookup_panelist

sub to_panelist {
    my ( $per_info, $names ) = @_;

    return unless $per_info;
    return $per_info unless $per_info->{ $PANELIST_OTHER };

    my $index     = $per_info->{ $PANELIST_INDEX };
    my $sub_index = 0;

    return map {
        lookup_panelist(
            $_, [ $index, ++$sub_index ],
            $per_info->{ $PANELIST_RANK }
        )
        }
        split m{\s*,\s*}xms, $names;
} ## end sub to_panelist

sub process_spreadsheet_add_panelist {
    my ( $panel, $per_info_index, $raw_text ) = @_;

    return unless defined $raw_text;

    my $unlisted = $raw_text =~ m{\A[*]}xms || $raw_text =~ m{[*]\z}xms;

    my @panelists = to_panelist( $per_info_index, $raw_text );
    my $seen;
    my $map;

    foreach my $per_info ( @panelists ) {
        my $per_name = $per_info->{ $PANELIST_NAME };

        unless ( $unlisted ) {
            $seen //= $panel->{ $FIELD_PANELIST_LISTED } //= {};
            $seen->{ $per_name } = $per_info;
        }
        $map //= $panel->{ $FIELD_PANELIST_MAP } //= {};

        $map->{ $per_name } = $per_info;

        if ( defined $per_info->{ $PANELIST_GROUP } ) {
            my $grp_info = $per_info->{ $PANELIST_GROUP };
            my $grp_name = $grp_info->{ $PANELIST_NAME };
            $map->{ $grp_name } = $grp_info;
        }

        if ( $per_info->{ $PANELIST_RANK } == $PANELIST_RANK_GUEST ) {
            $map->{ $GUEST_ANY } = $GUEST_ANY_INFO;
        }
    } ## end foreach my $per_info ( @panelists)

    return;
} ## end sub process_spreadsheet_add_panelist

sub process_spreadsheet_credit_panelist {
    my ( $panel ) = @_;

    if ( defined $panel->{ $TABLE_PANELIST_HIDE } ) {
        $panel->{ $FIELD_ALL_PANELIST } = undef;
        return;
    }

    if ( defined $panel->{ $TABLE_PANELIST_ALT } ) {
        $panel->{ $FIELD_ALL_PANELIST } = $panel->{ $TABLE_PANELIST_ALT };
        return;
    }

    my $seen = $panel->{ $FIELD_PANELIST_LISTED };
    if ( !defined $seen ) {
        $panel->{ $FIELD_ALL_PANELIST } = undef;
        return;
    }

    my %shown;
PANELIST:
    while ( my ( $per_name, $per_info ) = each %{ $seen } ) {
        if ( $per_info->{ $PANELIST_GROUP } ) {
            foreach my $member (
                keys %{ $per_info->{ $PANELIST_GROUP }->{ $GROUP_MEMBERS } } )
            {
                if ( !exists $seen->{ $member } ) {
                    $shown{ $per_name } = $per_info;
                    next PANELIST;
                }
            } ## end foreach my $member ( keys %...)
            $shown{ $per_info->{ $PANELIST_GROUP }->{ $PANELIST_NAME } }
                = $per_info->{ $PANELIST_GROUP };
            next PANELIST;
        } ## end if ( $per_info->{ $PANELIST_GROUP...})

        $shown{ $per_name } = $per_info;
    } ## end PANELIST: while ( my ( $per_name, $per_info...))

    if ( %shown ) {
        my @panelist = map { $_->{ $PANELIST_NAME } }
            sort {
                   $a->{ $PANELIST_RANK } <=> $b->{ $PANELIST_RANK }
                || $a->{ $PANELIST_INDEX } <=> $b->{ $PANELIST_INDEX }
                || $a->{ $PANELIST_SUBINDEX } <=> $b->{ $PANELIST_SUBINDEX }
                || $a->{ $PANELIST_NAME } cmp $b->{ $PANELIST_NAME }
            } values %shown;
        $panel->{ $FIELD_ALL_PANELIST } = join q{, }, @panelist;
    } ## end if ( %shown )

    return;
} ## end sub process_spreadsheet_credit_panelist

sub process_spreadsheet_time_range {
    my ( $panel ) = @_;

    my $start = str2time( $panel->{ $TABLE_START_TIME } );
    my $end   = $start;
    if ( defined $panel->{ $TABLE_DURATION } ) {
        my ( $hour, $min ) = split m{:}xms, $panel->{ $TABLE_DURATION }, 2;
        $min += $hour * $MIN_PER_HOUR;
        $end += $min * $SEC_PER_MIN;
    }
    if ( defined $panel->{ $TABLE_END_TIME } ) {
        my $given_end = str2time( $panel->{ $TABLE_END_TIME } );
        if ( defined $end && $end != $start && $end != $given_end ) {
            warn $panel->{ $TABLE_UNIQUE_ID },
                q{ has a mismatch between START:},
                decode_time( $start, q{both} ), q{ + DUR:},
                $panel->{ $TABLE_DURATION }, q{ = },
                decode_time( $end,       q{both} ), q{ and END:},
                decode_time( $given_end, q{both} ), qq{\n};
        } ## end if ( defined $end && $end...)
        $end = $given_end if defined $given_end;
    } ## end if ( defined $panel->{...})

    return ( $start, $end );
} ## end sub process_spreadsheet_time_range

sub process_spreadsheet_workshop {
    my ( $panel ) = @_;
    my @subclasses;

    my $difficulty = $panel->{ $TABLE_DIFFICULTY };
    if ( defined $difficulty && $difficulty =~ m{\A[?]+\z}xms ) {
        undef $difficulty;
        $panel->{ $TABLE_DIFFICULTY } = undef;
    }
    if ( defined $difficulty && $difficulty =~ m{\A\d+\z}xms ) {
        push @subclasses, sprintf $SUBCLASS_FMT_DIFFICULTY, $difficulty;
    }

    my $tokens = $panel->{ $TABLE_TOKENS };
    if ( defined $tokens && $tokens eq q{0} ) {
        undef $tokens;
        $panel->{ $TABLE_TOKENS } = undef;
    }
    if ( defined $tokens ) {
        push @subclasses, $SUBCLASS_NEED_TOKENS;
        $tokens =~ s{\A\s*}{}xms;
        $tokens =~ s{\s*\z}{}xms;
        $tokens = q{TBD} unless $tokens =~ m{\A\d+\z}xms;
        $panel->{ $TABLE_TOKENS } = $tokens;
    } ## end if ( defined $tokens )

    # todo(dpfister) - Consider capacity heree
    my $full = $panel->{ $TABLE_FULL };
    if ( defined $full ) {
        if ( $full =~ m{\Anot??}xms || $full eq q{} ) {
            undef $full;
            $panel->{ $TABLE_FULL } = undef;
        }
        else {
            push @subclasses, $SUBCLASS_FULL;
        }
    } ## end if ( defined $full )

    return @subclasses;
} ## end sub process_spreadsheet_workshop

sub process_spreadsheet_row {
    my ( $header, $san_header, $panelist_by_index, $raw ) = @_;

    my %panel;
    foreach my $index ( keys @{ $raw } ) {
        my $header_text = $header->[ $index ];
        my $header_alt  = $san_header->[ $index ];

        my $raw_text = $raw->[ $index ];
        if ( $raw_text =~ m{\s}xms ) {
            $raw_text =~ s{\A \s*}{}xms;
            $raw_text =~ s{\s* \z}{}xms;
        }
        $raw_text              = undef if $raw_text eq q{};
        $panel{ $header_text } = $raw_text;
        $panel{ $header_alt }  = $raw_text;

        if ( defined $panelist_by_index->[ $index ] && defined $raw_text ) {
            process_spreadsheet_add_panelist(
                \%panel,
                $panelist_by_index->[ $index ], $raw_text
            );
        } ## end if ( defined $panelist_by_index...)
    } ## end foreach my $index ( keys @{...})

    process_spreadsheet_credit_panelist( \%panel );

    return unless defined $panel{ $TABLE_START_TIME };
    return unless $panel{ $TABLE_PANEL_NAME } =~ m{\S}xms;

    my ( $start, $end ) = process_spreadsheet_time_range( \%panel );

    my $idx     = $panel{ $TABLE_ROOM_INDEX };
    my $uniq_id = $panel{ $TABLE_UNIQUE_ID };
    my $kind    = $uniq_id // q{Unknown};
    $kind =~ s{\d+[[:alpha:]]?\z}{}xms;

    state %ids_seen;

    if ( $ids_seen{ $uniq_id } ) {
        my $indx = ++$ids_seen{ $uniq_id };
        $uniq_id .= q{Dup} . $indx;
    }
    else {
        $ids_seen{ $uniq_id } = 1;
    }

    my $room_name  = $panel{ $TABLE_ROOM_NAME };
    my @subclasses = sprintf $SUBCLASS_FMT_TYPE, $kind;

    push @subclasses, process_spreadsheet_workshop( \%panel );

    if ( $panel{ $TABLE_KIND } eq $CAFE ) {
        $panel{ $FIELD_CAFE } = 1;
    }
    $panel{ $FIELD_START_TIME_SECONDS } = $start;
    $panel{ $FIELD_END_TIME_SECONDS }   = $end;
    $panel{ $FIELD_CSS_SUBCLASSES }     = \@subclasses;
    $panel{ $FIELD_CSS_HREF }           = $uniq_id;

    if ( $room_name =~ m{\ASPLIT}xmsi ) {
        next if $option_unified_grid;
        if ( $option_split_per_day ) {
            next unless $room_name =~ m{\ASPLITDAY}xmsi;
        }
        add_split $start, $panel{ $TABLE_PANEL_NAME };
        next;
    } ## end if ( $room_name =~ m{\ASPLIT}xmsi)

    return if $idx eq q{};
    return if $idx >= $ROOM_FIRST_HIDE_IDX;

    add_time $start;
    add_time $end;

    my $room = $rooms{ $idx } //= {
        $TABLE_ROOM_INDEX => $idx,
        $FIELD_ROOM_NAME  => $room_name,
        $TABLE_HOTEL_ROOM => $panel{ $TABLE_HOTEL_ROOM },
    };
    $panel{ $FIELD_ROOM_INFO } = $room;
    push @{ $panels_by_start{ $start } //= [] }, \%panel;

    return;
} ## end sub process_spreadsheet_row

sub read_spreadsheet_file {
    my $handle = open_file( $option_input_file );
    my $fh     = $handle->{ $HANDLE_FILE_HANDLE };

    my $header = splitline( $handle )
        or die qq{Missing header in: ${option_input_file}\n};
    my @san_header = map { santize_hdr( $_ ) } @{ $header };

    my @panelist_by_index = ();

    foreach my $index ( keys @{ $header } ) {
        my $header_text = $header->[ $index ];
        my $info        = lookup_panelist( $header_text, $index );
        next unless defined $info;
        $panelist_by_index[ $index ] = $info;
    } ## end foreach my $index ( keys @{...})

    while ( my $raw = splitline( $handle ) ) {
        last unless defined $raw;
        process_spreadsheet_row(
            $header, \@san_header, \@panelist_by_index,
            $raw
        );
    } ## end while ( my $raw = splitline...)

    close_file( $handle );
    undef $handle;

    @all_room_ids = sort { $a <=> $b } keys %rooms;
    @start_times  = sort { $a <=> $b } keys %schedule;

    return;
} ## end sub read_spreadsheet_file

sub add_panelist_busy {
    my ( $panel, @panelist_info ) = @_;
    my $pmap = $panel->{ $FIELD_PANELIST_MAP };
    my $cmap;
    foreach my $info ( @panelist_info ) {
        next unless defined $info;
        next unless $info->{ $PANELIST_IS_INDIVIDUAL };
        my $panelist = $info->{ $PANELIST_NAME };
        next if exists $pmap->{ $panelist };
        $cmap //= $panel->{ $FIELD_PANELIST_BUSY_ELSEWHERE } //= {};
        $cmap->{ $panelist } //= $info;
    } ## end foreach my $info ( @panelist_info)
    return;
} ## end sub add_panelist_busy

sub make_time_ranges {
    my %time_points = map  { $_ => 1 } ( keys %time_region, keys %schedule );
    my @time_points = sort { $a <=> $b } keys %time_points;

    my $region_active;
    my $region_start_time;
    my %panels_active;
    my $last_time;
    my %empty_times;

    my $process_time = sub {
        my ( $time ) = @_;

        # Add new panels
        foreach my $panel ( @{ $panels_by_start{ $time } } ) {
            my $room_idx = $panel->{ $TABLE_ROOM_INDEX };
            my $region_info
                = $panel->{ $FIELD_BY_REGION }->{ $region_start_time }
                //= {};    # fix visual code formatting error */
            $region_info->{ $FIELD_TABLE_ROWS } //= 0;
            $region_info->{ $FIELD_START_TIME_SECONDS } = $time;
            $panels_active{ $room_idx } = $panel;
        } ## end foreach my $panel ( @{ $panels_by_start...})

        my %timeslot_info;
        my $per_map;
        my @active_room_ids = keys %panels_active;
        foreach my $room_idx ( @active_room_ids ) {
            my $panel     = $panels_active{ $room_idx };
            my $panel_end = $panel->{ $FIELD_END_TIME_SECONDS };

            if ( !defined $panel_end || $panel_end <= $time ) {

                # Remove expired panels
                delete $panels_active{ $room_idx };
                next;
            } ## end if ( !defined $panel_end...)

            $timeslot_info{ $room_idx } = $panel;

            my $region_info
                = $panel->{ $FIELD_BY_REGION }->{ $region_start_time } //= {};

            ++$region_info->{ $FIELD_TABLE_ROWS };
            foreach my $info ( grep { defined }
                values %{ $panel->{ $FIELD_PANELIST_MAP } } )
            {
                my $panelist = $info->{ $PANELIST_NAME };
                $per_map //= $timeslot_info{ $FIELD_PANELIST_MAP } //= {};
                $per_map->{ $panelist } = $info;
            } ## end foreach my $info ( grep { defined...})

            $region_active->{ $FIELD_ACTIVE_ROOMS }->{ $room_idx } = 1;

        } ## end foreach my $room_idx ( @active_room_ids)

        if ( %timeslot_info ) {
            foreach my $empty ( keys %empty_times ) {
                $region_active->{ $FIELD_BY_ROW_SECONDS }->{ $empty } = {};
            }
            %empty_times = ();

            $region_active->{ $FIELD_BY_ROW_SECONDS }->{ $time }
                = \%timeslot_info;
            $last_time = $time;

            if ( defined $per_map ) {
                my @panelist_info = values %{ $per_map };
                foreach my $panel ( values %panels_active ) {
                    add_panelist_busy( $panel, @panelist_info );
                }
            } ## end if ( defined $per_map )
        } ## end if ( %timeslot_info )
        elsif ( defined $last_time ) {
            $empty_times{ $time } = 1;
        }
        return;
    };

    my $process_half_hours_upto = sub {
        my ( $split_time ) = @_;
        return unless defined $last_time;

        my $time = $last_time + $HALF_HOUR_IN_SEC;
        while ( $time < $split_time ) {
            $process_time->( $time );
            $time += $HALF_HOUR_IN_SEC;
        }

        return;
    };

    my $finish_region = sub {
        return unless defined $region_active;
        return unless $option_kiosk_mode;
        my $rows = $region_active->{ $FIELD_BY_ROW_SECONDS };
        return unless $rows;
        my $next_rows   = $region_active->{ $FIELD_NEXT_PANEL } //= {};
        my @times       = reverse sort { $a <=> $b } keys %{ $rows };
        my %next_panels = ();

        foreach my $time ( @times ) {
            my $next_panels = $next_rows->{ $time } //= {};
            foreach my $room_idx ( @all_room_ids ) {
                my $next = $next_panels{ $room_idx };
                $next_panels->{ $room_idx } = $next if defined $next;
            }
            foreach my $panel ( @{ $panels_by_start{ $time } } ) {
                my $room_idx = $panel->{ $TABLE_ROOM_INDEX };
                $next_panels{ $room_idx } = $panel;
            }
        } ## end foreach my $time ( @times )
    };

    my $check_for_next_region = sub {
        my ( $split_time ) = @_;

        my $next_range = $time_region{ $split_time };
        if ( !defined $next_range ) {
            return if defined $region_active;
            $next_range = add_split( $split_time, q{Before Convention} );
        }

        $finish_region->();
        foreach my $panel ( values %panels_active ) {
            my $region_info = $panel->{ $FIELD_BY_REGION }->{ $split_time }
                //= {};    # fix visual code formatting error */
            $region_info->{ $FIELD_TABLE_ROWS }         = 0;
            $region_info->{ $FIELD_START_TIME_SECONDS } = $split_time;
        } ## end foreach my $panel ( values ...)
        $region_active     = $next_range;
        $region_start_time = $split_time;
        undef $last_time;
        %empty_times = ();
    };

    foreach my $split_time ( @time_points ) {
        $process_half_hours_upto->( $split_time ) if %panels_active;
        $check_for_next_region->( $split_time );
        $process_time->( $split_time );
    }
    $finish_region->();

    return;
} ## end sub make_time_ranges

sub out_line {
    my ( @content ) = @_;
    my $indent = join q{}, ( qq{\t} x $level );
    my $content = join q{}, @content;
    foreach my $line ( split m{\n+}xms, $content ) {
        $line =~ s{\A\s+}{}xms;
        $line =~ s{\s+\Z}{}xms;
        next if $line eq q{};
        say { $output_file_handle } $indent, $line
            or die qq{Error writing ${output_file_name}: ${ERRNO}\n};
    } ## end foreach my $line ( split m{\n+}xms...)

    return;
} ## end sub out_line

sub out_open {
    my ( @content ) = @_;
    out_line $h->open( @content );
    ++$level;

    return;
} ## end sub out_open

sub out_close {
    my ( @content ) = @_;
    --$level;
    out_line $h->close( @content );

    return;
} ## end sub out_close

sub out_class {
    my ( @fields ) = @_;
    return unless @fields;
    my $res = join q{ }, @fields;
    $res =~ s{\s\s+}{ }xms;
    $res =~ s{\A\s}{}xms;
    $res =~ s{\s\z}{}xms;
    return if $res eq q{};
    return class => $res;
} ## end sub out_class

sub is_panelist_hosting {
    my ( $filter, $panel ) = @_;
    return unless defined $panel;
    return unless exists $filter->{ $FILTER_PANELIST };

    return 1
        if exists $panel->{ $FIELD_PANELIST_MAP }
        ->{ $filter->{ $FILTER_PANELIST }->{ $PANELIST_NAME } };

    return;
} ## end sub is_panelist_hosting

sub is_panelist_busy {
    my ( $filter, $panels_for_timeslot ) = @_;
    return unless exists $filter->{ $FILTER_PANELIST };

    my $panelist = $filter->{ $FILTER_PANELIST }->{ $PANELIST_NAME };
    return unless defined $panelist;

    foreach my $idx ( @all_room_ids ) {
        my $panel = $panels_for_timeslot->{ $idx };
        next unless defined $panel;
        return 1 if exists $panel->{ $FIELD_PANELIST_MAP }->{ $panelist };
    }
    return;
} ## end sub is_panelist_busy

sub decode_time {
    my ( $time, $field ) = @_;

    my @ltime = localtime $time;
    my $day   = strftime $FMT_DAY, @ltime;
    my $tm    = strftime $FMT_TIME, @ltime;

    if ( defined $field ) {
        my $out_day  = ( $field =~ m{(day|both)}xms );
        my $out_time = ( $field =~ m{(time|hour|both)}xms );
        if ( $out_day ) {
            return $out_time ? $day . q{ } . $tm : $day;
        }
        if ( $out_time ) {
            return $tm;
        }
    } ## end if ( defined $field )
    return ( $day, $tm );
} ## end sub decode_time

sub decode_time_id {
    my ( $time ) = @_;
    my @ltime = localtime $time;
    state $base_day = ( localtime $earliest )[ $LOCALTIME_DAY ];
    my $min  = $ltime[ $LOCALTIME_HOUR ];
    my $hour = $ltime[ $LOCALTIME_MIN ];
    my $day  = $ltime[ $LOCALTIME_DAY ] - $base_day;
    while ( $day < 0 ) {
        $day += $DAYS_PER_WEEK;
    }
    while ( $day >= $DAYS_PER_WEEK ) {
        $day -= $DAYS_PER_WEEK;
    }
    return ( ( $day * $HOUR_PER_DAY ) + $hour ) * $MIN_PER_HOUR + $min;
} ## end sub decode_time_id

sub room_indices_for_region {
    my ( $region ) = @_;

    if ( $option_hide_unused_rooms && defined $region ) {
        my @room_indices = keys %{ $region->{ $FIELD_ACTIVE_ROOMS } };
        return @room_indices if @room_indices;
    }
    return @all_room_ids;
} ## end sub room_indices_for_region

sub get_room_index_focus_map {
    my ( $filter, $region ) = @_;

    my @room_indices = room_indices_for_region( $region );

    if ( exists $filter->{ $FILTER_ROOM } ) {
        my %res = map { $_ => 0 } @room_indices;
        $res{ $filter->{ $FILTER_ROOM }->{ $TABLE_ROOM_INDEX } } = 1;
        return %res;
    }

    my %res = map { $_ => 1 } @room_indices;
    if ( @option_rooms ) {
    ROOM:
        foreach my $id ( @room_indices ) {
            my $name = $rooms{ $id }->{ $FIELD_ROOM_NAME };
            foreach my $match ( @option_rooms ) {
                if ( $name =~ m{\Q$match\E}xmsi ) {
                    next ROOM;
                }
            }
            $res{ $id } = 0;    # Mark as mismatch
        } ## end ROOM: foreach my $id ( @room_indices)
    } ## end if ( @option_rooms )

    return %res;
} ## end sub get_room_index_focus_map

sub dump_grid_row_room_names {
    my ( $filter, $kind, $room_focus_map ) = @_;

    if ( $option_show_day_column ) {
        out_line $h->th(
            {   out_class(
                    $CLASS_GRID_CELL_HEADER,
                    $kind eq $HTML_TABLE_HEAD ? $CLASS_GRID_COLUMN_DAY : ()
                )
            },
            $HEADING_DAY
        );
    } ## end if ( $option_show_day_column)
    out_line $h->th(
        {   out_class(
                $CLASS_GRID_CELL_HEADER,
                $kind eq $HTML_TABLE_HEAD ? $CLASS_GRID_COLUMN_TIME : ()
            )
        },
        $HEADING_TIME
    );

    foreach my $idx ( sort { $a <=> $b } keys %{ $room_focus_map } ) {
        my $hotel = $rooms{ $idx }->{ $TABLE_HOTEL_ROOM };
        my $name  = $rooms{ $idx }->{ $FIELD_ROOM_NAME };
        if ( $hotel ne $name ) {
            $name = $hotel . $h->br() . $name;
        }
        out_line $h->th(
            {   out_class(
                    $CLASS_GRID_CELL_HEADER, $CLASS_GRID_COLUMN_ROOM,
                    $CLASS_GRID_CELL_ROOM_NAME,
                    (     $room_focus_map->{ $idx }
                        ? $CLASS_GRID_CELL_FOCUS
                        : $CLASS_GRID_CELL_UNFOCUS
                    ),
                    $kind eq $HTML_TABLE_HEAD
                    ? ( sprintf $CLASS_GRID_COLUMN_FMT_ROOM_IDX, $idx )
                    : (),
                )
            },
            $name
        );
    } ## end foreach my $idx ( sort { $a...})

    return;
} ## end sub dump_grid_row_room_names

sub dump_grid_header {
    my ( $filter, $room_focus_map ) = @_;

    out_open $HTML_TABLE, { out_class( $CLASS_GRID_TABLE ) };

    out_open $HTML_COLGROUP;
    if ( $option_show_day_column ) {
        out_line $h->col( { out_class( $CLASS_GRID_COLUMN_DAY ) } );
    }
    out_line $h->col( { out_class( $CLASS_GRID_COLUMN_TIME ) } );

    foreach my $idx ( sort { $a <=> $b } keys %{ $room_focus_map } ) {
        out_line $h->col(
            { out_class( sprintf $CLASS_GRID_COLUMN_FMT_ROOM_IDX, $idx ) } );
    }
    out_close $HTML_COLGROUP;

    out_open $HTML_TABLE_HEAD;
    out_open $HTML_TABLE_ROW, { out_class( $CLASS_GRID_ROW_HEADER ) };
    dump_grid_row_room_names( $filter, $HTML_TABLE_HEAD, $room_focus_map );
    out_close $HTML_TABLE_ROW;
    out_close $HTML_TABLE_HEAD;

    out_open $HTML_TABLE_BODY;

    return;
} ## end sub dump_grid_header

sub dump_grid_cell_room {
    my ( $filter, $region, $time, $idx, $panel, $focus ) = @_;

    if ( !defined $panel ) {
        out_line q{<!--}, $rooms{ $idx }->{ $FIELD_ROOM_NAME }, q{-->},
            $h->td( { out_class( $CLASS_GRID_CELL_EMPTY ) } );
        return;
    }

    my $region_info = $panel->{ $FIELD_BY_REGION }
        ->{ $region->{ $FIELD_START_TIME_SECONDS } } // {};
    if ( $region_info->{ $FIELD_START_TIME_SECONDS } ne $time ) {
        out_line q{<!--}, $rooms{ $idx }->{ $FIELD_ROOM_NAME }, q{ },
            $panel->{ $TABLE_UNIQUE_ID }, q{ continued-->};
        return;
    }

    my $difficulty   = $panel->{ $TABLE_DIFFICULTY };
    my $name         = $panel->{ $TABLE_PANEL_NAME };
    my $all_panelist = $panel->{ $FIELD_ALL_PANELIST };
    my $tokens       = $panel->{ $TABLE_TOKENS };
    my $room         = $rooms{ $idx };

    if ( $panel->{ $FIELD_CAFE } ) {
        $all_panelist = $name;
        $name         = q{Café featuring};
    }

    my @subclasses = ( q{}, @{ $panel->{ $FIELD_CSS_SUBCLASSES } } );
    if ( exists $filter->{ $FILTER_PANELIST } ) {
        my $panelist = $filter->{ $FILTER_PANELIST }->{ $PANELIST_NAME };
        if ( $panel->{ $FIELD_PANELIST_MAP }->{ $panelist } ) {
            push @subclasses, $SUBCLASS_GUEST_PANEL;
        }
        if ( $panel->{ $FIELD_PANELIST_BUSY_ELSEWHERE }->{ $panelist } ) {
            push @subclasses, $SUBCLASS_BUSY_PANEL;
        }
    } ## end if ( exists $filter->{...})

    if ( $focus ) {
        push @subclasses, $CLASS_GRID_CELL_FOCUS;
    }
    else {
        push @subclasses, $CLASS_GRID_CELL_UNFOCUS;
    }

    out_line q{<!--}, $rooms{ $idx }->{ $FIELD_ROOM_NAME }, q{-->};
    out_open $HTML_TABLE_DATA,
        {
        id      => ( sprintf $ANCHOR_FMT_GRID, $panel->{ $FIELD_CSS_HREF } ),
        rowspan => ( $region_info->{ $FIELD_TABLE_ROWS } // 1 ),
        out_class(
            $CLASS_GRID_COLUMN_ROOM,
            map { sprintf $CLASS_GRID_CELL_FMT_SUBCLASS, $_ } @subclasses
        )
        };

    out_line $h->div(
        {   out_class(
                sprintf $CLASS_GRID_CELL_FMT_SUBCLASS, $SUBCLASS_PIECE_ID
            )
        },
        $panel->{ $TABLE_UNIQUE_ID }
    );
    out_open $HTML_ANCHOR, { href => q{#} . $panel->{ $FIELD_CSS_HREF } };

    if ( $panel->{ $TABLE_FULL } ) {
        out_line $h->div(
            {   out_class(
                    sprintf $CLASS_GRID_CELL_FMT_SUBCLASS,
                    $SUBCLASS_PIECE_FULL
                )
            },
            q{Workshop is Full}
        );
    } ## end if ( $panel->{ $TABLE_FULL...})
    out_line $h->span(
        {   out_class(
                sprintf $CLASS_GRID_CELL_FMT_SUBCLASS,
                $SUBCLASS_PIECE_NAME
            )
        },
        $name
    );

    if ( defined $tokens ) {
        out_line $h->div(
            {   out_class(
                    map { sprintf $CLASS_GRID_CELL_FMT_SUBCLASS, $_ } (
                        $SUBCLASS_PIECE_TOKENS,
                        sprintf $SUBCLASS_PIECE_FMT_TOKENS, $tokens
                    )
                )
            },
            q{Tokens: } . $tokens
        );
    } ## end if ( defined $tokens )

    if ( $all_panelist =~ m{\S}xms ) {
        out_line $h->span(
            {   out_class(
                    sprintf $CLASS_GRID_CELL_FMT_SUBCLASS,
                    $SUBCLASS_PIECE_PANELIST
                )
            },
            $all_panelist
        );
    } ## end if ( $all_panelist =~ ...)

    out_close $HTML_ANCHOR;
    out_close $HTML_TABLE_DATA;

    return;
} ## end sub dump_grid_cell_room

sub dump_grid_row_time {
    my ( $filter, $region, $room_focus_map, $time, $panels_for_timeslot )
        = @_;

    my @time_row_classes = $CLASS_GRID_ROW_TIME_SLOT;
    my @time_classes     = (
        $CLASS_GRID_CELL_HEADER,
        $CLASS_GRID_CELL_TIME_SLOT,
        $CLASS_GRID_COLUMN_TIME,
    );

    if ( exists $filter->{ $FILTER_PANELIST }
        && $panels_for_timeslot->{ $FIELD_PANELIST_MAP }
        ->{ $filter->{ $FILTER_PANELIST }->{ $PANELIST_NAME } } )
    {
        push @time_row_classes, $CLASS_GRID_ROW_PANELIST_BUSY;
        push @time_classes,     $CLASS_GRID_CELL_PANELIST_BUSY;
    } ## end if ( exists $filter->{...})

    my $time_id = q{sched_id_} . decode_time_id( $time );
    out_open $HTML_TABLE_ROW,
        { out_class( @time_row_classes ), id => $time_id };

    if ( $option_show_day_column ) {
        out_line $h->th(
            {   out_class(
                    $CLASS_GRID_CELL_HEADER, $CLASS_GRID_CELL_DAY,
                    $CLASS_GRID_COLUMN_DAY
                )
            },
            decode_time( $time, qw{ day } )
        );
        out_line $h->th(
            { out_class( @time_classes ) },
            decode_time( $time, qw{ time } )
        );
    } ## end if ( $option_show_day_column)
    else {
        my ( $day, $tm ) = decode_time( $time );
        if (   $region->{ $FIELD_LAST_TIME_OUTPUT } == $time
            || $region->{ $FIELD_DAY_BEING_OUTPUT } ne $day )
        {
            $tm = $day . $h->br() . $tm;
            $region->{ $FIELD_DAY_BEING_OUTPUT } = $day;
        } ## end if ( $region->{ $FIELD_LAST_TIME_OUTPUT...})
        out_line $h->th(
            { out_class( @time_classes ) },
            $tm
        );
    } ## end else [ if ( $option_show_day_column)]

    foreach my $idx ( sort { $a <=> $b } keys %{ $room_focus_map } ) {
        dump_grid_cell_room(
            $filter, $region, $time, $idx,
            $panels_for_timeslot->{ $idx },
            $room_focus_map->{ $idx }
        );
    } ## end foreach my $idx ( sort { $a...})
    out_close $HTML_TABLE_ROW;

    return;
} ## end sub dump_grid_row_time

sub dump_grid_footer {
    my ( $filter, $room_focus_map ) = @_;

    out_close $HTML_TABLE_BODY;
    out_open $HTML_TABLE_FOOT;
    out_open $HTML_TABLE_ROW, { out_class( $CLASS_GRID_ROW_HEADER ) };
    dump_grid_row_room_names( $filter, $HTML_TABLE_FOOT, $room_focus_map );
    out_close $HTML_TABLE_ROW;
    out_close $HTML_TABLE_FOOT;
    out_close $HTML_TABLE;

    return;
} ## end sub dump_grid_footer

sub dump_grid_timeslice {
    my ( $filter, $region ) = @_;

    my $rows = $region->{ $FIELD_BY_ROW_SECONDS };
    $region->{ $FIELD_DAY_BEING_OUTPUT } = undef;
    my @times = sort { $a <=> $b } keys %{ $rows };
    $region->{ $FIELD_LAST_TIME_OUTPUT } = $times[ -1 ];

    return unless @times;

    # todo(dpfister) Filter for times?

    my %room_focus_map = get_room_index_focus_map( $filter, $region );

    dump_grid_header( $filter, \%room_focus_map );
    foreach my $time ( @times ) {
        dump_grid_row_time(
            $filter, $region, \%room_focus_map, $time,
            $rows->{ $time }
        );
    } ## end foreach my $time ( @times )
    dump_grid_footer( $filter, \%room_focus_map );

    return;
} ## end sub dump_grid_timeslice

sub dump_desc_header {
    my ( $filter, $region, $show_unbusy_panels ) = @_;

    if ( exists $filter->{ $FILTER_PANELIST } ) {
        my $panelist = $filter->{ $FILTER_PANELIST }->{ $PANELIST_NAME };

        my $hdr_text
            = $show_unbusy_panels
            ? q{Other panels}
            : q{Schedule for } . $panelist;

        if ( $option_is_postcard ) {
            out_open $HTML_TABLE, { out_class( $CLASS_DESC_TYPE_TABLE ) };
            out_open $HTML_COLGROUP;
            out_line $h->col( { out_class( $CLASS_DESC_TYPE_COLUMN ) } );
            out_close $HTML_COLGROUP;

            out_line $h->thead(
                { out_class( $CLASS_DESC_TYPE_HEADER ) },
                $h->tr(
                    $h->th(
                        { out_class( $CLASS_DESC_TYPE_COLUMN ) },
                        $hdr_text
                    )
                )
            );
            out_open $HTML_TABLE_BODY;
            out_open $HTML_TABLE_ROW;
            out_open $HTML_TABLE_DATA;
        } ## end if ( $option_is_postcard)
        else {
            out_line $h->h2( $hdr_text );
        }
    } ## end if ( exists $filter->{...})

    state $my_idx = 0;
    my $alt_class = $CLASS_DESC_SECTION . ( ++$my_idx );
    out_open $HTML_DIV, { out_class( $CLASS_DESC_SECTION, $alt_class ) };

    return;
} ## end sub dump_desc_header

sub dump_desc_footer {
    my ( $filter, $region, $show_unbusy_panels ) = @_;

    out_close $HTML_DIV;

    if ( exists $filter->{ $FILTER_PANELIST } ) {
        if ( $option_is_postcard ) {
            out_close $HTML_TABLE_DATA;
            out_close $HTML_TABLE_ROW;
            out_close $HTML_TABLE_BODY;
            out_close $HTML_TABLE;
        } ## end if ( $option_is_postcard)
    } ## end if ( exists $filter->{...})

    return;
} ## end sub dump_desc_footer

sub dump_desc_time_start {
    my ( $time, @hdr_suffix ) = @_;

    out_open $HTML_TABLE, { out_class( $CLASS_DESC_TIME_TABLE ) };
    out_open $HTML_COLGROUP;
    out_line $h->col( { out_class( $CLASS_DESC_TIME_COLUMN ) } );
    out_close $HTML_COLGROUP;

    out_line $h->thead(
        { out_class( $CLASS_DESC_TIME_HEADER ) },
        $h->tr(
            $h->th(
                {   out_class(
                        $CLASS_DESC_TIME_COLUMN, $CLASS_DESC_TIME_SLOT
                    )
                },
                join q{ },
                decode_time( $time, qw{ both } ),
                @hdr_suffix
            )
        )
    );

    out_open $HTML_TABLE_BODY;

    return;
} ## end sub dump_desc_time_start

sub dump_desc_time_end {
    my ( $time ) = @_;

    out_close $HTML_TABLE_BODY;
    out_close $HTML_TABLE;

    return;
} ## end sub dump_desc_time_end

sub dump_desc_panel_body {
    my ( $filter, $region, $panel, @extra_classes ) = @_;

    if ( !defined $panel ) {
        out_line $h->td(
            { out_class( @extra_classes, $CLASS_KIOSK_DESC_CELL_EMPTY ) } );
        return;
    }

    my @subclasses = ( q{}, @{ $panel->{ $FIELD_CSS_SUBCLASSES } } );
    my $conflict;

    if ( exists $filter->{ $FILTER_PANELIST } ) {
        my $panelist = $filter->{ $FILTER_PANELIST }->{ $PANELIST_NAME };
        if ( $panel->{ $FIELD_PANELIST_MAP }->{ $panelist } ) {
            push @subclasses, $SUBCLASS_GUEST_PANEL;
        }
        elsif ( $panel->{ $FIELD_PANELIST_BUSY_ELSEWHERE }->{ $panelist } ) {
            push @subclasses, $SUBCLASS_BUSY_PANEL;
            $conflict = 1;
        }
    } ## end if ( exists $filter->{...})

    my $difficulty   = $panel->{ $TABLE_DIFFICULTY };
    my $name         = $panel->{ $TABLE_PANEL_NAME };
    my $all_panelist = $panel->{ $FIELD_ALL_PANELIST };
    my $tokens       = $panel->{ $TABLE_TOKENS };
    my $room         = $panel->{ $FIELD_ROOM_INFO };

    if ( $panel->{ $FIELD_CAFE } ) {
        $name = q{Cosplay Café Featuring } . $name;
    }

    out_open $HTML_TABLE_DATA,
        {
        id => $panel->{ $FIELD_CSS_HREF },
        out_class(
            @extra_classes,
            map { sprintf $CLASS_DESC_FMT_SUBCLASS, $_ } @subclasses
        )
        };
    out_open $HTML_DIV if $option_kiosk_mode;
    out_line $h->div(
        { out_class( sprintf $CLASS_DESC_FMT_SUBCLASS, $SUBCLASS_PIECE_ID ) },
        $panel->{ $TABLE_UNIQUE_ID }
    );
    out_line $h->a(
        {   href => q{#} . $panel->{ $FIELD_CSS_HREF } . q{Grid},
            out_class(
                sprintf $CLASS_DESC_FMT_SUBCLASS, $SUBCLASS_PIECE_NAME
            )
        },
        $name
    );

    if ( defined $tokens ) {
        out_line $h->div(
            {   out_class(
                    map { sprintf $CLASS_DESC_FMT_SUBCLASS, $_ } (
                        $SUBCLASS_PIECE_TOKENS,
                        sprintf $SUBCLASS_PIECE_FMT_TOKENS, $tokens
                    )
                )
            },
            q{Required tokens: } . $tokens
        );
    } ## end if ( defined $tokens )
    if ( $option_kiosk_mode ) {
        out_line $h->p(
            {   out_class(
                    sprintf $CLASS_DESC_FMT_SUBCLASS, $SUBCLASS_PIECE_START
                )
            },
            decode_time( $panel->{ $FIELD_START_TIME_SECONDS }, qw{ both } )
        );
    } ## end if ( $option_kiosk_mode)
    else {
        out_line $h->p(
            {   out_class(
                    sprintf $CLASS_DESC_FMT_SUBCLASS, $SUBCLASS_PIECE_ROOM
                )
            },
            $room->{ $TABLE_HOTEL_ROOM }
        );
    } ## end else [ if ( $option_kiosk_mode)]
    if ( $all_panelist =~ m{\S}xms ) {
        out_line $h->p(
            {   out_class(
                    sprintf $CLASS_DESC_FMT_SUBCLASS,
                    $SUBCLASS_PIECE_PANELIST
                )
            },
            $all_panelist
        );
    } ## end if ( $all_panelist =~ ...)

    my $descbody = $panel->{ $TABLE_DESCRIPTION };
    out_line $h->p(
        {   out_class(
                sprintf $CLASS_DESC_FMT_SUBCLASS, $SUBCLASS_PIECE_DESCRIPTION
            )
        },
        $panel->{ $TABLE_DESCRIPTION }
    );

    my @note;
    if ( $conflict ) {
        push @note, $h->b( q{Conflicts with one of your panels.} );
    }
    if ( defined $panel->{ $TABLE_NOTE } ) {
        push @note, $h->i( $panel->{ $TABLE_NOTE } );
    }
    if ( defined $panel->{ $TABLE_FULL } ) {
        push @note,
            $h->span(
            {   out_class(
                    sprintf $CLASS_DESC_FMT_SUBCLASS, $SUBCLASS_PIECE_FULL
                )
            },
            q{This workshop is full.}
            );
    } ## end if ( defined $panel->{...})
    if ( @note ) {
        out_line $h->p(
            {   out_class(
                    sprintf $CLASS_DESC_FMT_SUBCLASS, $SUBCLASS_PIECE_NOTE
                )
            },
            join q{ },
            @note
        );
    } ## end if ( @note )
    if ( defined $difficulty ) {
        out_line $h->p(
            {   out_class(
                    sprintf $CLASS_DESC_FMT_SUBCLASS,
                    $SUBCLASS_PIECE_DIFFICULTY
                )
            },
            q{Difficulty level: } . $difficulty
        );
    } ## end if ( defined $difficulty)
    out_close $HTML_DIV if $option_kiosk_mode;
    out_close $HTML_TABLE_DATA;

    return;
} ## end sub dump_desc_panel_body

sub dump_desc_body {
    my ( $filter, $region, $room_focus_map, $show_unbusy_panels ) = @_;
    my $filter_panelist = exists $filter->{ $FILTER_PANELIST };

    my $rows = $region->{ $FIELD_BY_ROW_SECONDS };
    $region->{ $FIELD_DAY_BEING_OUTPUT } = undef;
    my @times = sort { $a <=> $b } keys %{ $rows };
    $region->{ $FIELD_LAST_TIME_OUTPUT } = $times[ -1 ];

    foreach my $time ( @times ) {
        my $time_header_seen;
        my $panels_for_timeslot = $rows->{ $time };

        foreach my $idx ( @all_room_ids ) {
            next unless $room_focus_map->{ $idx };
            my $panel = $panels_for_timeslot->{ $idx };
            next unless defined $panel;
            next unless $panel->{ $FIELD_START_TIME_SECONDS } == $time;

            if ( is_panelist_hosting( $filter, $panel ) ) {
                next if $show_unbusy_panels;
            }
            elsif ( $filter_panelist ) {
                next unless $show_unbusy_panels;
            }

            if ( !defined $time_header_seen ) {
                $time_header_seen = 1;

                dump_desc_time_start(
                    $time,
                    $show_unbusy_panels
                        && is_panelist_busy( $filter, $panels_for_timeslot )
                    ? ( qw{ Conflict } )
                    : ()
                );
            } ## end if ( !defined $time_header_seen)

            out_open $HTML_TABLE_ROW, { out_class( $CLASS_DESC_PANEL_ROW ) };
            dump_desc_panel_body( $filter, $region, $panel );
            out_close $HTML_TABLE_ROW;
        } ## end foreach my $idx ( @all_room_ids)
        if ( $time_header_seen ) {
            dump_desc_time_end( $time );
        }
    } ## end foreach my $time ( @times )

    return;
} ## end sub dump_desc_body

sub dump_desc_timeslice {
    my ( $filter, $region ) = @_;

    my %room_focus_map = get_room_index_focus_map( $filter, $region );

    dump_desc_header( $filter, $region );
    dump_desc_body( $filter, $region, \%room_focus_map );
    dump_desc_footer( $filter, $region );

    if ( exists $filter->{ $FILTER_PANELIST } && !$option_just_panelist ) {
        dump_desc_header( $filter, $region, 1 );
        dump_desc_body( $filter, $region, \%room_focus_map, 1 );
        dump_desc_footer( $filter, $region, 1 );
    }

    return;
} ## end sub dump_desc_timeslice

sub dump_desc_all_timeslice {
    my ( $filter, $show_unbusy_panels ) = @_;

    dump_desc_header( $filter, undef, $show_unbusy_panels );
    foreach my $region_time ( sort { $a <=> $b } keys %time_region ) {
        my $region         = $time_region{ $region_time };
        my %room_focus_map = get_room_index_focus_map( $filter, $region );
        dump_desc_body(
            $filter, $region, \%room_focus_map,
            $show_unbusy_panels
        );
    } ## end foreach my $region_time ( sort...)
    dump_desc_footer( $filter, undef, $show_unbusy_panels );

    return;
} ## end sub dump_desc_all_timeslice

sub cache_inline_style {
    my ( $file ) = @_;
    return unless defined $file;
    state %cache;
    if (   !File::Spec->file_name_is_absolute( $file )
        && !-e $file
        && -e File::Spec->catfile( q{css}, $file ) )
    {
        $file = File::Spec->catfile( q{css}, $file );
    } ## end if ( !File::Spec->file_name_is_absolute...)
    return $cache{ $file } //= read_file(
        $file,
        { chomp => 1, array_ref => 1, err_mode => q{carp} }
    );
} ## end sub cache_inline_style

sub open_dump_file {
    my ( $filter, $def_name ) = @_;
    $def_name //= q{index};

    if ( $option_output eq q{-} ) {
        $output_file_handle = \*STDOUT;
        $output_file_name   = q{<STDOUT>};
        return;
    }

    my @subnames
        = map { santize_hdr $_ } @{ $filter->{ $FILTER_OUTPUT_NAME } };

    my $ofname = $option_output;
    if ( -d $ofname ) {
        push @subnames, $def_name unless @subnames;
        $ofname
            = File::Spec->catfile( $ofname, join q{.}, @subnames, q{html} );
    }
    elsif ( @subnames ) {
        my ( $vol, $dir, $base ) = File::Spec->splitpath( $ofname );
        my $suffix = q{html};
        if ( $base =~ s{[.](html?)\z}{}xms ) {
            $suffix = $1;
        }
        $base = join q{.}, $base, @subnames, $suffix;

        $ofname = File::Spec->catpath( $vol, $dir, $base );
    } ## end elsif ( @subnames )

    open $output_file_handle, q{>:encoding(utf8)}, $ofname
        or die qq{Unable to write: ${ofname}\n};

    $output_file_name = $ofname;
    return;
} ## end sub open_dump_file

sub close_dump_file {
    if ( $option_output ne q{-} && defined $output_file_handle ) {
        $output_file_handle->close
            or die qq{Unable to close ${output_file_name}: ${ERRNO}\n};
    }
    undef $output_file_handle;
    undef $output_file_name;

    return;
} ## end sub close_dump_file

sub dump_file_header {
    say { $output_file_handle } q{<!doctype html>}
        or die qq{Error writing ${output_file_name}: ${ERRNO}\n};

    out_open $HTML_HTML;
    out_open $HTML_HEAD;
    out_line $h->meta( { charset => q{UTF-8} } );
    out_line $h->meta(
        { name => q{apple-mobile-web-app-capable}, content => q{yes} } );
    out_line $h->title( $option_title );
    out_line $h->link(
        {   href =>
                q{https://fonts.googleapis.com/css?family=Nunito+Sans&display=swap},
            rel => q{stylesheet}
        }
    );

    my $is_in_styles;
    my $open_styles = sub {
        return if $is_in_styles;
        out_open $HTML_STYLE;
        $is_in_styles = 1;
    };
    my $close_styles = sub {
        return unless $is_in_styles;
        out_close $HTML_STYLE;
        undef $is_in_styles;
    };
    foreach my $style ( @option_css_styles ) {
        my $is_html = $style =~ m{.html?\z}xms;
        my $lines;
        if ( $option_embed_css || $is_html ) {
            $lines = cache_inline_style( $style );
        }
        if ( $lines ) {
            if ( $is_html ) {
                $close_styles->();
            }
            else {
                $open_styles->();
            }
            foreach my $line ( @{ $lines } ) {
                next if $line =~ m{[@]charset}xmsi;
                out_line $line;
            }
        } ## end if ( $lines )
        elsif ( !$is_html ) {
            $close_styles->();
            out_line $h->link(
                { href => $style, rel => q{stylesheet}, type => q{text/css} }
            );
        } ## end elsif ( !$is_html )
    } ## end foreach my $style ( @option_css_styles)
    $close_styles->();

    out_close $HTML_HEAD;

    return;
} ## end sub dump_file_header

sub dump_file_footer {
    out_close $HTML_HTML;

    return;
}

sub dump_table_one_region {
    my ( $filter ) = @_;

    if ( $option_show_grid ) {
        dump_grid_timeslice( $filter, $filter->{ $FILTER_SPLIT_TIMESTAMP } );
    }
    if ( $option_show_descriptions ) {
        dump_desc_timeslice( $filter, $filter->{ $FILTER_SPLIT_TIMESTAMP } );
    }

    return;
} ## end sub dump_table_one_region

sub dump_table_all_regions {
    my ( $filter ) = @_;

    my $need_all_desc = $option_show_descriptions;

    if ( $option_show_grid ) {
        foreach my $region_time ( sort { $a <=> $b } keys %time_region ) {
            my $region = $time_region{ $region_time };
            dump_grid_timeslice( $filter, $region );
            next unless $option_show_descriptions;
            next if $option_desc_at_end;

            dump_desc_timeslice( $filter, $region );
            undef $need_all_desc;
        } ## end foreach my $region_time ( sort...)
        if ( !$option_desc_at_end ) {
            return;
        }
    } ## end if ( $option_show_grid)

    if ( $need_all_desc ) {
        dump_desc_all_timeslice( $filter );
        if ( exists $filter->{ $FILTER_PANELIST } && !$option_just_panelist )
        {
            dump_desc_all_timeslice( $filter, 1 );
        }
    } ## end if ( $need_all_desc )

    return;
} ## end sub dump_table_all_regions

sub dump_tables {
    my ( $filter ) = @_;

    open_dump_file( $filter );

    dump_file_header;

    out_open $HTML_BODY;

    if ( exists $filter->{ $FILTER_SPLIT_TIMESTAMP } ) {
        dump_table_one_region( $filter );
    }
    else {
        dump_table_all_regions( $filter );
    }

    out_close $HTML_BODY;

    dump_file_footer;
    close_dump_file;

    return;
} ## end sub dump_tables

sub dump_kiosk_desc {
    my ( $region ) = @_;

    my $rows     = $region->{ $FIELD_BY_ROW_SECONDS };
    my @times    = sort { $a <=> $b } keys %{ $rows };
    my @room_ids = room_indices_for_region( $region );

    my $cur_rows  = $region->{ $FIELD_BY_ROW_SECONDS } //= {};
    my $next_rows = $region->{ $FIELD_NEXT_PANEL }     //= {};
    foreach my $time ( @times ) {
        my $time_id = q{desc_id_} . decode_time_id( $time );
        out_open $HTML_DIV,
            {
            out_class( $CLASS_KIOSK_DESCRIPTIONS, $CLASS_KIOSK_HIDDEN ),
            id => $time_id
            };
        out_open $HTML_TABLE, { out_class( $CLASS_DESC_TIME_TABLE ) };
        out_open $HTML_COLGROUP;
        out_line $h->col( { out_class( $CLASS_KIOSK_COLUMN_ROOM ) } );
        out_line $h->col( { out_class( $CLASS_KIOSK_COLUMN_CURRENT ) } );
        out_line $h->col( { out_class( $CLASS_KIOSK_COLUMN_FUTURE ) } );
        out_close $HTML_COLGROUP;
        out_open $HTML_TABLE_HEAD, { out_class( $CLASS_KIOSK_DESC_HEAD ) };
        out_open $HTML_TABLE_ROW,
            { out_class( $CLASS_KIOSK_DESC_ROW_HEADERS ) };
        out_line $h->th(
            {   out_class(
                    $CLASS_KIOSK_COLUMN_ROOM, $CLASS_KIOSK_DESC_CELL_HEADER
                )
            }
        );
        out_line $h->th(
            {   out_class(
                    $CLASS_KIOSK_COLUMN_CURRENT,
                    $CLASS_KIOSK_DESC_CELL_HEADER
                )
            },
            q{Current Panel}
        );
        out_line $h->th(
            {   out_class(
                    $CLASS_KIOSK_COLUMN_FUTURE, $CLASS_KIOSK_DESC_CELL_HEADER
                )
            },
            q{Upcoming Panel}
        );
        out_close $HTML_TABLE_ROW;
        out_close $HTML_TABLE_HEAD;
        out_open $HTML_TABLE_BODY, { out_class( $CLASS_KIOSK_DESC_BODY ) };
        my $cur_panels  = $cur_rows->{ $time };
        my $next_panels = $next_rows->{ $time };

        foreach my $idx ( @room_ids ) {
            my $hotel = $rooms{ $idx }->{ $TABLE_HOTEL_ROOM };
            my $name  = $rooms{ $idx }->{ $FIELD_ROOM_NAME };
            if ( $hotel ne $name ) {
                $name = $hotel . $h->br() . $name;
            }
            out_open $HTML_TABLE_ROW,
                { out_class( $CLASS_KIOSK_DESC_ROW_ROOM ) };
            out_line $h->th(
                {   out_class(
                        $CLASS_KIOSK_DESC_CELL_ROOM,
                        $CLASS_KIOSK_DESC_CELL_HEADER
                    )
                },
                $name
            );
            dump_desc_panel_body(
                $DEFAULT_FILTER,       $region,
                $cur_panels->{ $idx }, $CLASS_KIOSK_DESC_CELL_CURRENT
            );
            dump_desc_panel_body(
                $DEFAULT_FILTER,        $region,
                $next_panels->{ $idx }, $CLASS_KIOSK_DESC_CELL_FUTURE
            );
            out_close $HTML_TABLE_ROW;
        } ## end foreach my $idx ( @room_ids)
        out_close $HTML_TABLE_BODY;
        out_close $HTML_TABLE;
        out_close $HTML_DIV;
    } ## end foreach my $time ( @times )

    return;
} ## end sub dump_kiosk_desc

sub dump_kiosk {
    open_dump_file( $DEFAULT_FILTER, q{kiosk} );

    say { $output_file_handle } q{<!doctype html>}
        or die qq{Error writing ${output_file_name}: ${ERRNO}\n};

    out_open $HTML_HTML;
    out_open $HTML_HEAD;
    out_line $h->meta( { charset => q{UTF-8} } );
    out_line $h->meta(
        { name => q{apple-mobile-web-app-capable}, content => q{yes} } );
    out_line $h->title( $option_title );
    out_line $h->link(
        {   href => q{css/kiosk.css}, rel => q{stylesheet},
            type => q{text/css}
        }
    );
    out_line $h->script(
        { type => q{text/javascript}, src => q{js/kiosk.js} } );

    out_close $HTML_HEAD;
    out_open $HTML_BODY;

    out_open $HTML_DIV, { out_class( $CLASS_KIOSK_BAR ) };
    out_line $h->img(
        {   out_class( $CLASS_KIOSK_LOGO ),
            src => q{images/CosplayAmericaLogoAlt.svg},
            alt => q{Cosplay America}
        }
    );
    out_open $HTML_DIV,
        { out_class( $CLASS_KIOSK_TIME ), id => q{current_time} };
    out_line q{SOMEDAY ##:## ?M};
    out_close $HTML_DIV;
    out_close $HTML_DIV;

    out_line $h->div( { out_class( $CLASS_KIOSK_GRID_HEADERS ) } );
    out_open $HTML_DIV, { out_class( $CLASS_KIOSK_GRID_ROWS ) };
    foreach my $region_time ( sort { $a <=> $b } keys %time_region ) {
        my $region = $time_region{ $region_time };
        dump_grid_timeslice( $DEFAULT_FILTER, $region );
    }
    out_close $HTML_DIV;

    foreach my $region_time ( sort { $a <=> $b } keys %time_region ) {
        my $region = $time_region{ $region_time };
        dump_kiosk_desc( $region );
    }

    out_close $HTML_BODY;
    out_close $HTML_HTML;

    close_dump_file;

    return;
} ## end sub dump_kiosk

sub split_filter_by_timestamp {
    my ( @filters ) = @_;

    return @filters unless $option_file_per_day;

    my @res;
    foreach my $filter ( @filters ) {
        my %new_filter = %{ $filter };
        my @subname    = @{ $new_filter{ $FILTER_OUTPUT_NAME } };
        foreach my $time ( sort { $a <=> $b } keys %time_region ) {
            my $region = $time_region{ $time };
            push @res, {
                %new_filter,
                $FILTER_SPLIT_TIMESTAMP => $region,
                $FILTER_OUTPUT_NAME =>
                    [ @subname, $region->{ $FIELD_REGION_NAME } ],
            };
        } ## end foreach my $time ( sort { $a...})
    } ## end foreach my $filter ( @filters)

    return @res;
} ## end sub split_filter_by_timestamp

sub split_filter_by_panelist {
    my ( @filters ) = @_;

    return @filters
        unless ( $option_file_per_guest || $option_file_per_panelist );

    my @res;
    foreach my $filter ( @filters ) {
        my %new_filter = %{ $filter };
        my @subname    = @{ $new_filter{ $FILTER_OUTPUT_NAME } };
        foreach my $per_info ( values %panelist_info ) {
            next if $per_info->{ $PANELIST_OTHER };

            if ( $per_info->{ $PANELIST_RANK } == $PANELIST_RANK_GUEST
                && !$option_file_per_panelist )
            {
                next;
            }

            push @res, {
                %new_filter,
                $FILTER_PANELIST => $per_info,
                $FILTER_OUTPUT_NAME =>
                    [ @subname, $per_info->{ $PANELIST_NAME } ],
            };
        } ## end foreach my $per_info ( values...)
    } ## end foreach my $filter ( @filters)

    return @res;
} ## end sub split_filter_by_panelist

sub split_filter_by_room {
    my ( @filters ) = @_;

    return @filters unless $option_file_per_room;

    my @res;
    foreach my $filter ( @filters ) {
        my %new_filter = %{ $filter };
        my @subname    = @{ $new_filter{ $FILTER_OUTPUT_NAME } };
        foreach my $room_idx ( room_indices_for_region() ) {
            my $room = $rooms{ $room_idx };
            push @res, {
                %new_filter,
                $FILTER_ROOM => $room,
                $FILTER_OUTPUT_NAME =>
                    [ @subname, $room->{ $FIELD_ROOM_NAME } ],
            };
        } ## end foreach my $room_idx ( room_indices_for_region...)
    } ## end foreach my $filter ( @filters)

    return @res;
} ## end sub split_filter_by_room

sub main {
    my ( @args ) = @_;

    GetOptionsFromArray(
        \@args,
        q{day!}              => \$option_show_day_column,
        q{descriptions!}     => \$option_show_descriptions,
        q{file-by-day!}      => \$option_file_per_day,
        q{file-by-guest!}    => \$option_file_per_guest,
        q{file-by-panelist!} => \$option_file_per_panelist,
        q{file-by-room!}     => \$option_file_per_room,
        q{grid!}             => \$option_show_grid,
        q{hide-unused!}      => \$option_hide_unused_rooms,
        q{inline-css!}       => \$option_embed_css,
        q{input=s}           => \$option_input_file,
        q{just-guest!}       => \$option_just_panelist,
        q{just-panelist!}    => \$option_just_panelist,
        q{kiosk!}            => \$option_kiosk_mode,
        q{output=s}          => \$option_output,
        q{postcard!}         => \$option_is_postcard,
        q{room=s@}           => \@option_rooms,
        q{separate!}         => \$option_desc_at_end,
        q{split-day!}        => \$option_split_per_day,
        q{style=s@}          => \@option_css_styles,
        q{title=s}           => \$option_title,
        q{unified!}          => \$option_unified_grid,
    ) or die qq{Usage: desc_tbl -input [file] -output [file]\n};

    $option_embed_css //= 1 if @option_css_styles;
    push @option_css_styles, qw{ index.css } unless @option_css_styles;

    $option_input_file //= shift @args;
    $option_output     //= shift @args;
    $option_output     //= q{-};
    $option_title      //= q{Cosplay America 2022 Schedule};

    if ( $option_kiosk_mode ) {
        @option_css_styles        = ();
        $option_desc_at_end       = undef;
        $option_embed_css         = undef;
        $option_file_per_day      = undef;
        $option_file_per_guest    = undef;
        $option_file_per_panelist = undef;
        $option_file_per_room     = undef;
        @option_rooms             = ();
        $option_is_postcard       = undef;
        $option_just_panelist     = undef;
        $option_show_day_column   = undef;
        $option_show_descriptions = 1;
        $option_show_grid         = 1;
        $option_split_per_day     = undef;
        $option_unified_grid      = 1;
    } ## end if ( $option_kiosk_mode)
    read_spreadsheet_file( $option_input_file );

    make_time_ranges;

    if ( $option_kiosk_mode ) {
        dump_kiosk;
        return;
    }

    $option_show_grid         //= 0 if $option_show_descriptions;
    $option_show_descriptions //= 0 if $option_show_grid;
    $option_show_grid         //= 1;
    $option_show_descriptions //= 1;
    $option_file_per_guest //= 1 if $option_just_panelist;

    my @filters = ( $DEFAULT_FILTER );
    @filters = split_filter_by_panelist( @filters );
    @filters = split_filter_by_room( @filters );
    @filters = split_filter_by_timestamp( @filters );

    foreach my $filter ( @filters ) {
        dump_tables( $filter );
    }

    return;
} ## end sub main

main( @ARGV );

1;

__END__
