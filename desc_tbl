#!/usr/bin/perl

use common::sense;
use utf8;
use Text::CSV;
use Date::Parse qw{ str2time };
use POSIX qw{ strftime };
use HTML::Tiny qw{};
use Readonly;
use Carp qw{verbose};
use Getopt::Long qw{GetOptionsFromArray};
use File::Slurp qw{read_file};

# Global variables
Readonly our $HALF_HOUR => 30 * 60;
Readonly our $CAFE      => q{Café};

our $fname;
our $oname;
our $day_column;
our $unified;
our $perday;
our $separate_desc;
our $inline_style;

our %schedule;
our %rooms;
our %time_region;

our @room_ids;
our @start_times;
our $ofh;
our $level = 0;
our $h = HTML::Tiny->new( mode => q{html} );

sub splitline {
    my ( $fh ) = @_;
    my $line = $fh->getline;
    return unless defined $line;
    my $full_line = $line;
    my @raw = split m{\t}xms, $line;
    my @res;
    while ( @raw ) {
        my $piece = shift @raw;
        if ( $piece =~ m{ \A " }xms ) {
            my $full = $piece;
            while ( $full
                !~ m{ \A " (?: [^"]++ | (?: "" )++ )* " (?:\n\r?+|\r\n?+)?+ \z }xms
                )
            {
                unless ( @raw ) {
                    chomp $full_line;
                    die "Unable to process: [", $full, "]\nin line: ",
                        $full_line, qq{\n};
                }
                $full .= shift @raw;
            } ## end while ( $full !~ ...)
            $full =~ s{ \A " }{}xms;
            $full =~ s{ (?:\n\r?+|\r\n?+)?+ \z }{}xms;
            $full =~ s{ " \z }{}xms;
            $full =~ s{ "" }{"}xmsg;
            push @res, $full;
        } ## end if ( $piece =~ m{ \A " }xms)
        else {
            push @res, $piece;
        }
    } ## end while ( @raw )
    return \@res;
} ## end sub splitline

sub time_split {
    my ( $time ) = @_;
    return unless defined $time;
    if ( $time =~ s{ \s ([AP]M) \z}{}xms ) {
        return $time, $1;
    }
    else {
        return $time;
    }
} ## end sub time_split

sub add_split {
    my ( $time, $name ) = @_;
    $time_region{ $time }->{ name } = $name;
}

sub add_time {
    my ( $time ) = @_;
    return if $schedule{ $time };
    $schedule{ $time } = 1;
}

sub read_csv_file {
    open my $fh, "<:encoding(utf16)", $fname
        or die qq{Unable to read: $fname\n};

    my $header = splitline( $fh )
        or die "Missing header in: ", $fname, "\n";

    my %ids;

    while ( my $raw = splitline( $fh ) ) {
        last unless defined $raw;
        my %panel;
        foreach my $index ( keys @{ $raw } ) {
            my $header_text = $header->[ $index ];
            my $header_alt  = $header_text;
            $header_alt =~ s{\s+}{_}xmsg;
            $header_alt =~ s{/}{_}xmsg;
            $header_alt =~ s{_+}{_}xmsg;
            my $raw_text = $raw->[ $index ];
            if ( $raw_text =~ m{\s} ) {
                $raw_text =~ s{\A \s*}{}xms;
                $raw_text =~ s{\s* \z}{}xms;
            }
            $raw_text = undef if $raw_text eq q{};
            $panel{ $header_text } = $raw_text;
            $panel{ $header_alt }  = $raw_text;
        } ## end foreach my $index ( keys @{...})
        next unless defined $panel{ Start_Time };
        next unless $panel{ Name } =~ m{\S}xms;
        my $start = str2time( $panel{ Start_Time } );
        my $end
            = defined $panel{ End_Time }
            ? str2time( $panel{ End_Time } )
            : $start;
        my $idx  = $panel{ Room_Idx };
        my $id   = $panel{ Uniq_ID };
        my $kind = $id // q{Unknown};
        $kind =~ s{\d+[[:alpha:]]?\z}{}xms;

        if ( $ids{ $id } ) {
            my $indx = ++$ids{ $id };
            $id .= q{Dup} . $indx;
        }
        else {
            $ids{ $id } = 1;
        }

        my $room_name  = $panel{ Room };
        my $difficulty = $panel{ Difficulty };
        my $tokens     = $panel{ Tokens };
        my @classes    = q{Type} . $kind;
        if ( $difficulty =~ m{\A\d+\z}xms ) {
            push @classes, q{Difficulty} . $difficulty;
        }
        if ( $tokens eq q{0} ) {
            undef $tokens;
        }
        if ( defined $tokens ) {
            push @classes, q{NeedTokens};
            $tokens =~ s{\A\s*}{}xms;
            $tokens =~ s{\s*\z}{}xms;
            $tokens = q{TBD} unless $tokens =~ m{\A\d+\z}xms;
        } ## end if ( defined $tokens )

        if ( $panel{ Kind } eq $CAFE ) {
            $panel{ Cafe } = 1;
        }
        $panel{ Start_Tm }   = $start;
        $panel{ End_Tm }     = $end;
        $panel{ Table_Rows } = 0;
        $panel{ Class }      = \@classes;
        $panel{ HRef }       = $id;
        $panel{ Tokens }     = $tokens;

        if ( $room_name =~ m{\ASPLIT}xmsi ) {
            next if $unified;
            if ( $perday ) {
                next unless $room_name =~ m{\ASPLITDAY}xmsi;
            }
            add_split $start, $panel{ Name };
            next;
        } ## end if ( $room_name =~ m{\ASPLIT}xmsi)

        next if $idx eq q{};
        next if $idx > 90;

        add_time $start;
        add_time $end;

        my $room = $rooms{ $idx } //= {};
        $panel{ RoomInfo } = $room;
        $room->{ $idx } = $idx;
        $room->{ name }  //= $room_name;
        $room->{ hotel } //= $panel{ Real_Room };
        $room->{ start }->{ $start } = \%panel;
        $room->{ end }->{ $end }     = \%panel;
    } ## end while ( my $raw = splitline...)

    $fh->close
        or die qq{Unable to close $fname: $!\n};

    @room_ids    = sort { $a <=> $b } keys %rooms;
    @start_times = sort { $a <=> $b } keys %schedule;

} ## end sub read_csv_file

sub make_time_ranges {
    my %time_points = map { $_ => 1 } ( keys %time_region, keys %schedule );
    my @time_points = sort { $a <=> $b } keys %time_points;

    my $active_range;
    my %active_panels;
    my $last_time;

    my $process_time = sub {
        my ( $time ) = @_;

        foreach my $room_idx ( @room_ids ) {
            my $room = $rooms{ $room_idx };
            if ( exists $active_panels{ $room_idx } ) {
                my $panel     = $active_panels{ $room_idx };
                my $panel_end = $panel->{ End_Tm };
                if ( $panel_end <= $time ) {
                    delete $active_panels{ $room_idx };
                }
            } ## end if ( exists $active_panels...)
            if ( defined( my $new_panel = $room->{ start }->{ $time } ) ) {
                $new_panel->{ Table_Start } = $time;
                $active_panels{ $room_idx } = $new_panel;
            }
        } ## end foreach my $room_idx ( @room_ids)
        foreach my $panel ( values %active_panels ) {
            ++$panel->{ Table_Rows };
        }
        if ( defined $last_time || %active_panels ) {
            $active_range->{ row }->{ $time } = { %active_panels };
            $last_time = $time;
        }
        return;
    };

    my $process_half_hours = sub {
        my ( $split_time ) = @_;
        return unless defined $last_time;
        for (
            my $time = $last_time + $HALF_HOUR ;
            $time < $split_time ;
            $time += $HALF_HOUR
            )
        {
            $process_time->( $time );
        } ## end for ( my $time = $last_time...)
        return;
    };

    foreach my $split_time ( @time_points ) {
        if ( !defined $active_range ) {
            $time_region{ $split_time }->{ name } //= q{Before Convention};
        }
        my $next_range = $time_region{ $split_time };

        if ( defined $next_range ) {
            if ( %active_panels ) {
                $process_half_hours->( $split_time );
            }
            foreach my $room_idx ( keys %active_panels ) {
                my %panel = %{ $active_panels{ $room_idx } };
                $panel{ across_region }     = 1;
                $panel{ Table_Rows }        = 0;
                $panel{ Table_Start }       = $split_time;
                $active_panels{ $room_idx } = \%panel;
            } ## end foreach my $room_idx ( keys...)
            $active_range = $next_range;
            undef $last_time;
        } ## end if ( defined $next_range)
        elsif ( %active_panels ) {
            $process_half_hours->( $split_time );
        }
        $process_time->( $split_time );
    } ## end foreach my $split_time ( @time_points)
} ## end sub make_time_ranges

sub out_line {
    my ( @content ) = @_;
    my $indent = join q{}, ( qq{\t} x $level );
    my $content = join q{}, @content;
    foreach my $line ( split m{\n+}xms, $content ) {
        $line =~ s{\A\s+}{}xms;
        $line =~ s{\s+\Z}{}xms;
        next if $line eq q{};
        say { $ofh } $indent, $line;
    } ## end foreach my $line ( split m{\n+}xms...)
} ## end sub out_line

sub out_open {
    my ( @content ) = @_;
    out_line $h->open( @content );
    ++$level;
}

sub out_close {
    my ( @content ) = @_;
    --$level;
    out_line $h->close( @content );
}

sub out_class {
    my ( @fields ) = @_;
    return unless @fields;
    my $res = join q{ }, @fields;
    $res =~ s{\s\s+}{ }xms;
    $res =~ s{\A\s}{}xms;
    $res =~ s{\s\z}{}xms;
    return if $res eq q{};
    return class => $res;
} ## end sub out_class

sub decode_time {
    my ( $time, $field ) = @_;

    my @ltime = localtime $time;
    my $day   = strftime q{%A}, @ltime;
    my $tm    = strftime q{%I:%M %p}, @ltime;

    if ( defined $field ) {
        my $out_day  = ( $field =~ m{(day|both)}xms );
        my $out_time = ( $field =~ m{(time|hour|both)}xms );
        if ( $out_day ) {
            return $out_time ? $day . q{ } . $tm : $day;
        }
        if ( $out_time ) {
            return $tm;
        }
    } ## end if ( defined $field )
    return ( $day, $tm );
} ## end sub decode_time

sub dump_labels {
    my ( $kind ) = @_;

    if ( $day_column ) {
        out_line $h->th(
            {   out_class(
                    qw{schedhead}, $kind eq q{head} ? qw{scheddaycolumn} : ()
                )
            },
            q{Day}
        );
    } ## end if ( $day_column )
    out_line $h->th(
        {   out_class(
                qw{schedhead}, $kind eq q{head} ? qw{schedtimecolumn} : ()
            )
        },
        q{Time}
    );
    foreach my $idx ( @room_ids ) {
        out_line $h->th(
            {   out_class(
                    qw{schedhead schedloccolumn roomloc},
                    $kind eq q{head} ? qq{schedloc${idx}column} : ()
                )
            },
            $rooms{ $idx }->{ hotel } . $h->br() . $rooms{ $idx }->{ name }
        );
    } ## end foreach my $idx ( @room_ids)

} ## end sub dump_labels

sub dump_header {
    my ( $region ) = @_;

    out_open qw{ table }, { out_class( qw{ schedule } ) };

    out_open qw{ colgroup };
    if ( $day_column ) {
        out_line $h->col( { out_class( qw{ scheddaycolumn } ) } );
    }
    out_line $h->col( { out_class( qw{ schedtimecolumn } ) } );
    foreach my $idx ( @room_ids ) {
        out_line $h->col( { class => qq{schedloc${idx}column} } );
    }
    out_close qw{ colgroup };

    out_open qw{ thead };
    out_open qw{ tr }, { out_class( qq{schedheadrow} ) };
    dump_labels qw{ head };
    out_close qw{ tr };
    out_close qw{ thead };

    out_open qw{ tbody };
} ## end sub dump_header

sub dump_room {
    my ( $time, $idx, $panel ) = @_;

    if ( !defined $panel ) {
        out_line q{<!--}, $rooms{ $idx }->{ name }, q{-->},
            $h->td( { out_class( qw{ empty } ) } );
        return;
    }
    if ( $panel->{ Table_Start } ne $time ) {
        out_line q{<!--}, $rooms{ $idx }->{ name }, q{ },
            $panel->{ Uniq_ID }, q{ continued-->};
        return;
    }

    my $difficulty = $panel->{ Difficulty };
    my $name       = $panel->{ Name };
    my $panelist   = $panel->{ Panelist };
    my $tokens     = $panel->{ Tokens };
    my $room       = $rooms{ $idx };

    if ( $panel->{ Cafe } ) {
        $panelist = $name;
        $name     = q{Café featuring};
    }

    my @classes = ( q{}, @{ $panel->{ Class } } );

    out_line q{<!--}, $rooms{ $idx }->{ name }, q{-->};
    out_open qw{ td },
        {
        id      => $panel->{ HRef } . q{Grid},
        rowspan => $panel->{ Table_Rows },
        out_class(
            qw{ schedloccolumn },
            map { q{panel} . $_ } @classes
        )
        };

    out_line $h->div( { out_class( qw{ panelid } ) }, $panel->{ Uniq_ID } );
    out_open q{a}, { href => q{#} . $panel->{ HRef } };

    out_line $h->span( { out_class( qw{ panelname } ) }, $name );

    if ( defined $tokens ) {
        out_line $h->div(
            { out_class( qw{ paneltokens }, qq{paneltokens${tokens}} ) },
            q{Tokens: } . $tokens
        );
    } ## end if ( defined $tokens )

    if ( $panelist =~ m{\S}xms ) {
        out_line $h->span(
            { out_class( qw{ panelist } ) },
            $panelist
        );
    } ## end if ( $panelist =~ m{\S}xms)

    out_close qw{ a };
    out_close qw{ td };
} ## end sub dump_room

sub dump_row {
    my ( $region, $time, $panels ) = @_;

    out_open qw{ tr }, { out_class( qw{ schedtimerow } ) };

    if ( $day_column ) {
        out_line $h->th(
            { out_class( qw{ schedhead schedday scheddaycolumn } ) },
            decode_time( $time, qw{ day } )
        );
        out_line $h->th(
            { out_class( qw{ schedhead schedtime schedtimecolumn } ) },
            decode_time( $time, qw{ time } )
        );
    } ## end if ( $day_column )
    else {
        my ( $day, $tm ) = decode_time( $time );
        if (   $region->{ lasttime } == $time
            || $region->{ activeday } ne $day )
        {
            $tm = $day . $h->br() . $tm;
            $region->{ activeday } = $day;
        } ## end if ( $region->{ lasttime...})
        out_line $h->th(
            { out_class( qw{ schedhead schedtime schedtimecolumn } ) },
            $tm
        );
    } ## end else [ if ( $day_column ) ]

    foreach my $idx ( @room_ids ) {
        dump_room( $time, $idx, $panels->{ $idx } );
    }
    out_close qw{ tr };
} ## end sub dump_row

sub dump_foot {
    out_close qw{ tbody };
    out_open qw{ tfoot };
    out_open qw{ tr }, { out_class( qq{schedheadrow} ) };
    dump_labels qw{ foot };
    out_close qw{ tr };
    out_close qw{ tfoot };
    out_close qw{ table };
} ## end sub dump_foot

sub dump_region {
    my ( $region ) = @_;

    dump_header( $region );
    my $rows = $region->{ row };
    $region->{ activeday } = undef;
    my @times = sort { $a <=> $b } keys %{ $rows };
    $region->{ lasttime } = $times[ -1 ];
    foreach my $time ( @times ) {
        dump_row( $region, $time, $rows->{ $time } );
    }
    dump_foot( $region );
} ## end sub dump_region

sub dump_desc_time_start {
    my ( $region, $time ) = @_;

    out_open qw{ table }, { out_class( qw{ desctime } ) };
    out_open qw{ colgroup };
    out_line $h->col( { out_class( qw{ desccol } ) } );
    out_close qw{ colgroup };
    out_line $h->thead(
        { out_class( qw{desctimeheader} ) },
        $h->tr(
            $h->th(
                { out_class( qw{desccol} ) }, decode_time( $time, qw{ both } )
            )
        )
    );
    out_open qw{ tbody };
    out_open qw{ tr }, { out_class( qw{desctimebody} ) };
    out_open qw{ td };
    out_open qw{ ul }, { out_class( qw{desctimebody} ) };
} ## end sub dump_desc_time_start

sub dump_desc_time_end {
    my ( $region, $time ) = @_;

    out_close qw{ ul };
    out_close qw{ td };
    out_close qw{ tr };
    out_close qw{ tbody };
    out_close qw{ table };
} ## end sub dump_desc_time_end

sub dump_desc_panel {
    my ( $region, $time, $panel ) = @_;

    my $difficulty = $panel->{ Difficulty };
    my $name       = $panel->{ Name };
    my $panelist   = $panel->{ Panelist };
    my $tokens     = $panel->{ Tokens };
    my $room       = $panel->{ RoomInfo };

    if ( $panel->{ Cafe } ) {
        $name = q{Cosplay Café Featuring } . $name;
    }

    my @classes = ( q{}, @{ $panel->{ Class } } );

    out_open qw{ li },
        {
        id => $panel->{ HRef },
        out_class( map { q{desc} . $_ } @classes )
        };
    out_line $h->div(
        { out_class( qw{ descid } ) },
        $panel->{ Uniq_ID }
    );
    out_line $h->a(
        {   href => q{#} . $panel->{ HRef } . q{Grid},
            out_class( qw{descname} )
        },
        $name
    );

    if ( defined $tokens ) {
        out_line $h->div(
            { out_class( qw{ descTokens }, qq{descTokens{$tokens}} ) },
            q{Required tokens: } . $tokens
        );
    } ## end if ( defined $tokens )
    out_line $h->p( { out_class( qw{ descroom } ) }, $room->{ hotel } );
    if ( $panelist =~ m{\S}xms ) {
        out_line $h->p( { out_class( qw{ descpanelist} ) }, $panelist );
    }
    out_line $h->p(
        { out_class( qw{ descbody } ) },
        $panel->{ Description }
    );
    if ( defined $panel->{ Note } ) {
        out_line $h->p(
            { out_class( qw{ descnote } ) },
            $h->i( $panel->{ Note } )
        );
    } ## end if ( defined $panel->{...})
    if ( defined $difficulty ) {
        out_line $h->p(
            {   out_class(
                    qw{ descDifficulty }, qq{descDifficulty${difficulty}}
                )
            },
            q{Difficulty level: } . $difficulty
        );
    } ## end if ( defined $difficulty)
    out_close qw{ li };
} ## end sub dump_desc_panel

sub dump_desc_region_rows {
    my ( $region ) = @_;

    my $rows = $region->{ row };
    $region->{ activeday } = undef;
    my @times = sort { $a <=> $b } keys %{ $rows };
    $region->{ lasttime } = $times[ -1 ];
    foreach my $time ( @times ) {
        my $need_time_header = 1;
        my $panels           = $rows->{ $time };
        foreach my $idx ( @room_ids ) {
            my $panel = $panels->{ $idx };
            if ( $panel->{ Start_Tm } == $time ) {
                if ( $need_time_header ) {
                    dump_desc_time_start( $region, $time );
                    undef $need_time_header;
                }
                dump_desc_panel( $region, $time, $panel );
            } ## end if ( $panel->{ Start_Tm...})
        } ## end foreach my $idx ( @room_ids)
        unless ( $need_time_header ) {
            dump_desc_time_end( $region, $time );
        }
    } ## end foreach my $time ( @times )
} ## end sub dump_desc_region_rows

sub dump_desc_region {
    my ( $region ) = @_;

    dump_desc_region_rows( $region );
}

sub dump_tables {
    my %time_points = map { $_ => 1 } ( keys %time_region );

    if ( $oname eq q{-} ) {
        $ofh = \*STDOUT;
    }
    else {
        open $ofh, ">:encoding(utf8)", $oname
            or die qq{Unable to write: $oname\n};
    }

    say { $ofh } q{<!doctype html>};
    out_open qw{ html };
    out_open qw{ head };
    out_line $h->meta( { charset => q{UTF-8} } );
    out_line $h->title( q{Cosplay America 2019 Schedule} );
    out_line $h->link(
        {   href =>
                q{https://fonts.googleapis.com/css?family=Nunito+Sans&display=swap},
            rel => q{stylesheet}
        }
    );
    if ( defined $inline_style ) {
        my $lines = read_file(
            $inline_style,
            { chomp => 1, array_ref => 1, err_mode => q{carp} }
        );
        if ( $lines ) {
            out_open qw{style};
            foreach my $line ( @{ $lines } ) {
                out_line $line;
            }
            out_close qw{style};
        } ## end if ( $lines )
        else {
            undef $inline_style;
        }
    } ## end if ( defined $inline_style)
    if ( !defined $inline_style ) {
        out_line $h->link(
            {   href => q{index.css}, rel => q{stylesheet},
                type => q{text/css}
            }
        );
    } ## end if ( !defined $inline_style)
    out_close qw{ head };
    out_open qw{ body };

    foreach my $region_time ( sort { $a <=> $b } keys %time_region ) {
        my $region = $time_region{ $region_time };
        dump_region( $region );
        dump_desc_region( $region ) unless $separate_desc;
    }

    if ( $separate_desc ) {
        foreach my $region_time ( sort { $a <=> $b } keys %time_region ) {
            my $region = $time_region{ $region_time };
            dump_desc_region_rows( $region );
        }
    } ## end if ( $separate_desc )

    out_close qw{ body };
    out_close qw{ html };

    if ( $oname ne q{-} ) {
        $ofh->close
            or die qq{Unable to close $oname: $!\n};
    }

} ## end sub dump_tables

sub main {
    my ( @args ) = @_;

    GetOptionsFromArray(
        \@args,
        q{input=s}   => \$fname,
        q{output=s}  => \$oname,
        q{day!}      => \$day_column,
        q{unified!}  => \$unified,
        q{perday!}   => \$perday,
        q{separate!} => \$separate_desc,
        q{style=s}   => \$inline_style
    ) or die qq{Usage: desc_tbl -input [file] -output [file]\n};

    $fname //= shift @args;
    $oname //= shift @args;
    $oname //= q{-};

    read_csv_file( $fname );

    make_time_ranges;

    dump_tables;
} ## end sub main

main( @ARGV );

1;
