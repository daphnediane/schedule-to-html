#!/usr/bin/perl

use common::sense;
use strict;
use utf8;
use Text::CSV;
use File::Spec;
use Date::Parse qw{ str2time };
use POSIX qw{ strftime };
use HTML::Tiny qw{};
use Readonly;
use Carp qw{verbose};
use Getopt::Long qw{GetOptionsFromArray};
use File::Slurp qw{read_file};

# Global variables
Readonly our $HALF_HOUR    => 30 * 60;
Readonly our $CAFE         => q{Café};
Readonly our $GUEST_ANY    => q{All Guests};
Readonly our $GUEST_J_OR_M => q{Jin and Miguel};

# Panel fields
Readonly our $TABLE_DESCRIPTION => q{Description};
Readonly our $TABLE_DIFFICULTY  => q{Difficulty};
Readonly our $TABLE_END_TIME    => q{End_Time};
Readonly our $TABLE_FULL        => q{Full};
Readonly our $TABLE_HOTEL_ROOM  => q{Real_Room};
Readonly our $TABLE_KIND        => q{Kind};
Readonly our $TABLE_NOTE        => q{Note};
Readonly our $TABLE_PANEL_NAME  => q{Name};
Readonly our $TABLE_PANELIST    => q{Panelist};
Readonly our $TABLE_ROOM_INDEX  => q{Room_Idx};
Readonly our $TABLE_ROOM_NAME   => q{Room};
Readonly our $TABLE_START_TIME  => q{Start_Time};
Readonly our $TABLE_TOKENS      => q{Tokens};
Readonly our $TABLE_UNIQUE_ID   => q{Uniq_ID};

# Custom fields
Readonly our $FIELD_BY_REGION          => q{*BY_REGION};
Readonly our $FIELD_BY_ROW_SECONDS     => q{*BY_SECONDS};
Readonly our $FIELD_CAFE               => q{*CAFE};
Readonly our $FIELD_CSS_SUBCLASSES     => q{*CLASSES};
Readonly our $FIELD_CSS_HREF           => q{*HREF};
Readonly our $FIELD_DAY_BEING_OUTPUT   => q{*ACTIVEDAY};
Readonly our $FIELD_END_TIME_SECONDS   => q{*END_SEC};
Readonly our $FIELD_GUEST_CONFLICT     => q{*GUEST_CONFLICT};
Readonly our $FIELD_GUEST_MAP          => q{*GUEST_MAP};
Readonly our $FIELD_LAST_TIME_OUTPUT   => q{*LASTTIME};
Readonly our $FIELD_REGION_NAME        => q{*NAME};
Readonly our $FIELD_ROOM_INFO          => q{*ROOM_INFO};
Readonly our $FIELD_ROOM_NAME          => q{*NAME};
Readonly our $FIELD_START_TIME_SECONDS => q{*START_SEC};
Readonly our $FIELD_TABLE_ROWS         => q{*NUM_ROWS};
Readonly our $FIELD_ACTIVE_ROOMS       => q{*ROOMS};

# HTML Elements
Readonly our $HTML_ANCHOR     => q{a};
Readonly our $HTML_BODY       => q{body};
Readonly our $HTML_COLGROUP   => q{colgroup};
Readonly our $HTML_DIV        => q{div};
Readonly our $HTML_HEAD       => q{head};
Readonly our $HTML_HTML       => q{html};
Readonly our $HTML_STYLE      => q{style};
Readonly our $HTML_TABLE      => q{table};
Readonly our $HTML_TABLE_BODY => q{tbody};
Readonly our $HTML_TABLE_DATA => q{td};
Readonly our $HTML_TABLE_FOOT => q{tfoot};
Readonly our $HTML_TABLE_HEAD => q{thead};
Readonly our $HTML_TABLE_ROW  => q{tr};

# HTML Anchors
Readonly our $ANCHOR_FMT_GRID => q{%sGrid};

# CSS Classes
Readonly our $CLASS_DESC_FMT_SUBCLASS        => q{desc%s};
Readonly our $CLASS_DESC_PANEL_ROW           => q{descPanelRow};
Readonly our $CLASS_DESC_SECTION             => q{descriptions};
Readonly our $CLASS_DESC_TIME_COLUMN         => q{descTimeSlotColumn};
Readonly our $CLASS_DESC_TIME_HEADER         => q{descTimeSlotRowHeader};
Readonly our $CLASS_DESC_TIME_SLOT           => q{descTimeSlot};
Readonly our $CLASS_DESC_TIME_TABLE          => q{descTimeSlotTable};
Readonly our $CLASS_DESC_TYPE_COLUMN         => q{descTypeColumn};
Readonly our $CLASS_DESC_TYPE_HEADER         => q{descTypeHeader};
Readonly our $CLASS_DESC_TYPE_TABLE          => q{descTypeTable};
Readonly our $CLASS_GRID_CELL_DAY            => q{schedWeekDay};
Readonly our $CLASS_GRID_CELL_EMPTY          => q{schedRoomEmpty};
Readonly our $CLASS_GRID_CELL_FMT_SUBCLASS   => q{panel%s};
Readonly our $CLASS_GRID_CELL_GUEST_BUSY     => q{schedTimeSlotGuestBusy};
Readonly our $CLASS_GRID_CELL_HEADER         => q{schedHeader};
Readonly our $CLASS_GRID_CELL_ROOM_NAME      => q{schedRoomName};
Readonly our $CLASS_GRID_CELL_TIME_SLOT      => q{schedTimeSlot};
Readonly our $CLASS_GRID_COLUMN_DAY          => q{schedColumnDay};
Readonly our $CLASS_GRID_COLUMN_FMT_ROOM_IDX => q{schedColumnRoom%s};
Readonly our $CLASS_GRID_COLUMN_ROOM         => q{schedColumnsRoom};
Readonly our $CLASS_GRID_COLUMN_TIME         => q{schedColumnTime};
Readonly our $CLASS_GRID_ROW_GUEST_BUSY      => q{schedRowTimeSlotGuestBusy};
Readonly our $CLASS_GRID_ROW_HEADER          => q{schedRowHeaders};
Readonly our $CLASS_GRID_ROW_TIME_SLOT       => q{schedRowTimeSlot};
Readonly our $CLASS_GRID_TABLE               => q{schedule};

# CSS Subclasses
Readonly our $SUBCLASS_CONFLICT_PANEL    => q{ConflictGuest};
Readonly our $SUBCLASS_FMT_DIFFICULTY    => q{Difficulty%s};
Readonly our $SUBCLASS_FMT_TYPE          => q{Type%s};
Readonly our $SUBCLASS_FULL              => q{Full};
Readonly our $SUBCLASS_GUEST_PANEL       => q{SelectedGuest};
Readonly our $SUBCLASS_NEED_TOKENS       => q{NeedTokens};
Readonly our $SUBCLASS_PIECE_DESCRIPTION => q{Description};
Readonly our $SUBCLASS_PIECE_FMT_TOKENS  => q{Tokens%s};
Readonly our $SUBCLASS_PIECE_FULL        => q{FullLabel};
Readonly our $SUBCLASS_PIECE_ID          => q{ID};
Readonly our $SUBCLASS_PIECE_NAME        => q{Name};
Readonly our $SUBCLASS_PIECE_NOTE        => q{Note};
Readonly our $SUBCLASS_PIECE_PANELIST    => q{Panelist};
Readonly our $SUBCLASS_PIECE_ROOM        => q{RoomName};
Readonly our $SUBCLASS_PIECE_TOKENS      => q{Tokens};
Readonly our $SUBCLASS_PIECE_DIFFICULTY  => q{Difficulty};

# Grid headers
Readonly our $HEADING_DAY  => q{Day};
Readonly our $HEADING_TIME => q{Time};

# Formatting strings
Readonly our $FMT_DAY  => q{%A};
Readonly our $FMT_TIME => q{%I:%M %p};

our $fname;
our $oname;
our $day_column;
our $unified;
our $perday;
our $separate_desc;
our @styles;
our $inline_css;
our $split_guest;
our $postcard;
our $just_guest;
our $hide_unused;
our $show_grid;
our $show_descriptions;

our %guests;
our %schedule;
our %rooms;
our %panels_by_start;
our %time_region;

our @all_room_ids;
our @start_times;
our $ofh;
our $level = 0;
our $h = HTML::Tiny->new( mode => q{html} );

sub splitline {
    my ( $fh ) = @_;
    my $line = $fh->getline;
    return unless defined $line;
    my $full_line = $line;
    my @raw = split m{\t}xms, $line;
    my @res;
    while ( @raw ) {
        my $piece = shift @raw;
        if ( $piece =~ m{ \A " }xms ) {
            my $full = $piece;
            while ( $full
                !~ m{ \A " (?: [^"]++ | (?: "" )++ )* " (?:\n\r?+|\r\n?+)?+ \z }xms
                )
            {
                unless ( @raw ) {
                    chomp $full_line;
                    die
                        qq{Unable to process: [${full}]\nin line: ${full_line}\n};
                }
                $full .= shift @raw;
            } ## end while ( $full !~ ...)
            $full =~ s{ \A " }{}xms;
            $full =~ s{ (?:\n\r?+|\r\n?+)?+ \z }{}xms;
            $full =~ s{ " \z }{}xms;
            $full =~ s{ "" }{"}xmsg;
            push @res, $full;
        } ## end if ( $piece =~ m{ \A " }xms)
        else {
            push @res, $piece;
        }
    } ## end while ( @raw )
    return \@res;
} ## end sub splitline

sub time_split {
    my ( $time ) = @_;
    return unless defined $time;
    if ( $time =~ s{ \s ([AP]M) \z}{}xms ) {
        return $time, $1;
    }
    else {
        return $time;
    }
} ## end sub time_split

sub add_split {
    my ( $time, $name ) = @_;
    my $region = $time_region{ $time } //= {};
    $region->{ $FIELD_REGION_NAME } //= $name;
    $region->{ $FIELD_START_TIME_SECONDS } = $time;
    return $region;
} ## end sub add_split

sub add_time {
    my ( $time ) = @_;
    return if $schedule{ $time };
    $schedule{ $time } = 1;
}

sub santize_hdr {
    my ( $hdr ) = @_;
    $hdr =~ s{\s+}{_}xmsg;
    $hdr =~ s{/}{_}xmsg;
    $hdr =~ s{[().,]}{_}xmsg;
    $hdr =~ s{_+}{_}xmsg;
    $hdr =~ s{\A_}{}xmsg;
    $hdr =~ s{_\z}{}xmsg;
    return $hdr;
} ## end sub santize_hdr

sub read_csv_file {
    open my $fh, q{<:encoding(utf16)}, $fname
        or die qq{Unable to read: ${fname}\n};

    my $header = splitline( $fh )
        or die qq{Missing header in: ${fname}\n};

    my %ids;

    my $in_guest_columns;
    while ( my $raw = splitline( $fh ) ) {
        last unless defined $raw;
        my %panel;
        foreach my $index ( keys @{ $raw } ) {
            my $header_text = $header->[ $index ];
            my $header_alt  = santize_hdr( $header_text );

            undef $in_guest_columns if $header_alt =~ m{\AStaff\z}xmsi;

            my $raw_text = $raw->[ $index ];
            if ( $raw_text =~ m{\s} ) {
                $raw_text =~ s{\A \s*}{}xms;
                $raw_text =~ s{\s* \z}{}xms;
            }
            $raw_text = undef if $raw_text eq q{};
            $panel{ $header_text } = $raw_text;
            $panel{ $header_alt }  = $raw_text;

            if ( $in_guest_columns && defined $raw_text ) {
                my @guests = ( $header_text );
                if ( $header_alt =~ m{\AOther_Guests?\z}xmsi ) {
                    @guests = split m{\s*,\s*}xms, $raw_text;
                }
                if ( $header_text =~ m{\(CC\)}xms ) {
                    push @guests, q{Cowbutt Crunchies};
                }
                if ( @guests ) {
                    push @guests, $GUEST_ANY;
                }
                if ( $header_text =~ m{\A ( Jin | Miguel ) \b }xmsi ) {
                    push @guests, $GUEST_J_OR_M;
                }
                foreach my $guest ( @guests ) {
                    $guests{ $guest } = santize_hdr( $guest );
                    $panel{ $FIELD_GUEST_MAP }->{ $guest } = 1;
                }
            } ## end if ( $in_guest_columns...)
            $in_guest_columns = 1 if $header_alt =~ m{\AGuests\z}xmsi;
        } ## end foreach my $index ( keys @{...})
        next unless defined $panel{ $TABLE_START_TIME };
        next unless $panel{ $TABLE_PANEL_NAME } =~ m{\S}xms;
        my $start = str2time( $panel{ $TABLE_START_TIME } );
        my $end
            = defined $panel{ $TABLE_END_TIME }
            ? str2time( $panel{ $TABLE_END_TIME } )
            : $start;
        my $idx  = $panel{ $TABLE_ROOM_INDEX };
        my $id   = $panel{ $TABLE_UNIQUE_ID };
        my $kind = $id // q{Unknown};
        $kind =~ s{\d+[[:alpha:]]?\z}{}xms;

        if ( $ids{ $id } ) {
            my $indx = ++$ids{ $id };
            $id .= q{Dup} . $indx;
        }
        else {
            $ids{ $id } = 1;
        }

        my $room_name  = $panel{ $TABLE_ROOM_NAME };
        my $difficulty = $panel{ $TABLE_DIFFICULTY };
        my $tokens     = $panel{ $TABLE_TOKENS };
        my $full       = $panel{ $TABLE_FULL };
        my @subclasses = sprintf $SUBCLASS_FMT_TYPE, $kind;
        if ( defined $difficulty && $difficulty =~ m{\A[?]+\z}xms ) {
            undef $difficulty;
            $panel{ $TABLE_DIFFICULTY } = undef;
        }
        if ( defined $difficulty && $difficulty =~ m{\A\d+\z}xms ) {
            push @subclasses, sprintf $SUBCLASS_FMT_DIFFICULTY, $difficulty;
        }
        if ( defined $tokens && $tokens eq q{0} ) {
            undef $tokens;
        }
        if ( defined $tokens ) {
            push @subclasses, $SUBCLASS_NEED_TOKENS;
            $tokens =~ s{\A\s*}{}xms;
            $tokens =~ s{\s*\z}{}xms;
            $tokens = q{TBD} unless $tokens =~ m{\A\d+\z}xms;
        } ## end if ( defined $tokens )
        if ( defined $full ) {
            if ( $full =~ m{\Anot??}xms || $full eq q{} ) {
                undef $full;
            }
            else {
                push @subclasses, $SUBCLASS_FULL;
            }
        } ## end if ( defined $full )

        if ( $panel{ $TABLE_KIND } eq $CAFE ) {
            $panel{ $FIELD_CAFE } = 1;
        }
        $panel{ $FIELD_START_TIME_SECONDS } = $start;
        $panel{ $FIELD_END_TIME_SECONDS }   = $end;
        $panel{ $FIELD_CSS_SUBCLASSES }     = \@subclasses;
        $panel{ $FIELD_CSS_HREF }           = $id;
        $panel{ $TABLE_TOKENS }             = $tokens;
        $panel{ $TABLE_FULL }               = $full;

        if ( $room_name =~ m{\ASPLIT}xmsi ) {
            next if $unified;
            if ( $perday ) {
                next unless $room_name =~ m{\ASPLITDAY}xmsi;
            }
            add_split $start, $panel{ $TABLE_PANEL_NAME };
            next;
        } ## end if ( $room_name =~ m{\ASPLIT}xmsi)

        next if $idx eq q{};
        next if $idx >= 100;

        add_time $start;
        add_time $end;

        my $room = $rooms{ $idx } //= {};
        $panel{ $FIELD_ROOM_INFO } = $room;
        $room->{ $TABLE_ROOM_INDEX } = $idx;
        $room->{ $FIELD_ROOM_NAME }  //= $room_name;
        $room->{ $TABLE_HOTEL_ROOM } //= $panel{ $TABLE_HOTEL_ROOM };
        push @{ $panels_by_start{ $start } //= [] }, \%panel;
    } ## end while ( my $raw = splitline...)

    $fh->close
        or die qq{Unable to close $fname: $!\n};

    @all_room_ids = sort { $a <=> $b } keys %rooms;
    @start_times  = sort { $a <=> $b } keys %schedule;

} ## end sub read_csv_file

sub add_guest_conflicts {
    my ( $panel, @guests ) = @_;
    my $gmap = $panel->{ $FIELD_GUEST_MAP };
    my $cmap;
    foreach my $guest ( @guests ) {
        next if $guest eq $GUEST_ANY;
        next if $gmap->{ $guest };
        $cmap //= $panel->{ $FIELD_GUEST_CONFLICT } //= {};
        next if $cmap->{ $guest };
        $cmap->{ $guest } = 1;
    } ## end foreach my $guest ( @guests)
    return;
} ## end sub add_guest_conflicts

sub make_time_ranges {
    my %time_points = map { $_ => 1 } ( keys %time_region, keys %schedule );
    my @time_points = sort { $a <=> $b } keys %time_points;

    my $region_active;
    my $region_start_time;
    my %panels_active;
    my $last_time;
    my %empty_times;

    my $process_time = sub {
        my ( $time ) = @_;

        # Add new panels
        foreach my $panel ( @{ $panels_by_start{ $time } } ) {
            my $room_idx = $panel->{ $TABLE_ROOM_INDEX };
            my $region_info
                = $panel->{ $FIELD_BY_REGION }->{ $region_start_time }
                //= {};    # fix visual code formatting error */
            $region_info->{ $FIELD_TABLE_ROWS } //= 0;
            $region_info->{ $FIELD_START_TIME_SECONDS } = $time;
            $panels_active{ $room_idx } = $panel;
        } ## end foreach my $panel ( @{ $panels_by_start...})

        my $panels_for_timeslot;
        my $guest_map;
        my @active_room_ids = keys %panels_active;
        foreach my $room_idx ( @active_room_ids ) {
            my $panel     = $panels_active{ $room_idx };
            my $panel_end = $panel->{ $FIELD_END_TIME_SECONDS };

            if ( !defined $panel_end || $panel_end <= $time ) {

                # Remove expired panels
                delete $panels_active{ $room_idx };
                next;
            } ## end if ( !defined $panel_end...)

            $panels_for_timeslot //= {};
            $panels_for_timeslot->{ $room_idx } = $panel;

            my $region_info
                = $panel->{ $FIELD_BY_REGION }->{ $region_start_time } //= {};

            ++$region_info->{ $FIELD_TABLE_ROWS };
            my $gmap = $panel->{ $FIELD_GUEST_MAP };
            if ( defined $gmap ) {
                foreach my $guest ( keys %{ $gmap } ) {
                    next unless $gmap->{ $guest };
                    $guest_map //= $panels_for_timeslot->{ $FIELD_GUEST_MAP }
                        //= {};    # fix visual code formatting error */
                    $guest_map->{ $guest } = 1;
                } ## end foreach my $guest ( keys %{...})
            } ## end if ( defined $gmap )

            $region_active->{ $FIELD_ACTIVE_ROOMS }->{ $room_idx } = 1;

        } ## end foreach my $room_idx ( @active_room_ids)

        if ( defined $panels_for_timeslot ) {
            foreach my $empty ( keys %empty_times ) {
                $region_active->{ $FIELD_BY_ROW_SECONDS }->{ $empty } = {};
            }
            %empty_times = ();

            $region_active->{ $FIELD_BY_ROW_SECONDS }->{ $time }
                = $panels_for_timeslot;
            $last_time = $time;

            if ( defined $guest_map ) {
                my @guests = keys %{ $guest_map };
                foreach my $panel ( values %panels_active ) {
                    add_guest_conflicts( $panel, @guests );
                }
            } ## end if ( defined $guest_map)
        } ## end if ( defined $panels_for_timeslot)
        elsif ( defined $last_time ) {
            $empty_times{ $time } = 1;
        }
        return;
    };

    my $process_half_hours_upto = sub {
        my ( $split_time ) = @_;
        return unless defined $last_time;
        for (
            my $time = $last_time + $HALF_HOUR ;
            $time < $split_time ;
            $time += $HALF_HOUR
            )
        {
            $process_time->( $time );
        } ## end for ( my $time = $last_time...)
        return;
    };

    my $check_for_next_region = sub {
        my ( $split_time ) = @_;

        my $next_range = $time_region{ $split_time };
        if ( !defined $next_range ) {
            return if defined $region_active;
            $next_range = add_split( $split_time, q{Before Convention} );
        }

        foreach my $panel ( values %panels_active ) {
            my $region_info
                = $panel->{ $FIELD_BY_REGION }->{ $split_time } //= {};
            $region_info->{ $FIELD_TABLE_ROWS }         = 0;
            $region_info->{ $FIELD_START_TIME_SECONDS } = $split_time;
        } ## end foreach my $panel ( values ...)
        $region_active     = $next_range;
        $region_start_time = $split_time;
        undef $last_time;
        %empty_times = ();
    };

    foreach my $split_time ( @time_points ) {
        $process_half_hours_upto->( $split_time ) if %panels_active;
        $check_for_next_region->( $split_time );
        $process_time->( $split_time );
    }
} ## end sub make_time_ranges

sub out_line {
    my ( @content ) = @_;
    my $indent = join q{}, ( qq{\t} x $level );
    my $content = join q{}, @content;
    foreach my $line ( split m{\n+}xms, $content ) {
        $line =~ s{\A\s+}{}xms;
        $line =~ s{\s+\Z}{}xms;
        next if $line eq q{};
        say { $ofh } $indent, $line;
    } ## end foreach my $line ( split m{\n+}xms...)
} ## end sub out_line

sub out_open {
    my ( @content ) = @_;
    out_line $h->open( @content );
    ++$level;
}

sub out_close {
    my ( @content ) = @_;
    --$level;
    out_line $h->close( @content );
}

sub out_class {
    my ( @fields ) = @_;
    return unless @fields;
    my $res = join q{ }, @fields;
    $res =~ s{\s\s+}{ }xms;
    $res =~ s{\A\s}{}xms;
    $res =~ s{\s\z}{}xms;
    return if $res eq q{};
    return class => $res;
} ## end sub out_class

sub has_guest {
    my ( $panels_for_timeslot, $guest, @invalid_result ) = @_;
    return @invalid_result unless defined $guest;
    return @invalid_result unless exists $guests{ $guest };
    foreach my $idx ( @all_room_ids ) {
        my $panel = $panels_for_timeslot->{ $idx };
        next unless defined $panel;
        return 1 if $panel->{ $FIELD_GUEST_MAP }->{ $guest };
    }
    return;
} ## end sub has_guest

sub decode_time {
    my ( $time, $field ) = @_;

    my @ltime = localtime $time;
    my $day   = strftime $FMT_DAY, @ltime;
    my $tm    = strftime $FMT_TIME, @ltime;

    if ( defined $field ) {
        my $out_day  = ( $field =~ m{(day|both)}xms );
        my $out_time = ( $field =~ m{(time|hour|both)}xms );
        if ( $out_day ) {
            return $out_time ? $day . q{ } . $tm : $day;
        }
        if ( $out_time ) {
            return $tm;
        }
    } ## end if ( defined $field )
    return ( $day, $tm );
} ## end sub decode_time

sub room_ids {
    my ( $region ) = @_;

    if ( $hide_unused && defined $region ) {
        my @room_ids
            = sort { $a <=> $b } keys %{ $region->{ $FIELD_ACTIVE_ROOMS } };
        return @room_ids if @room_ids;
    }
    return @all_room_ids;
} ## end sub room_ids

sub dump_labels {
    my ( $kind, $region ) = @_;

    if ( $day_column ) {
        out_line $h->th(
            {   out_class(
                    $CLASS_GRID_CELL_HEADER,
                    $kind eq $HTML_TABLE_HEAD ? $CLASS_GRID_COLUMN_DAY : ()
                )
            },
            $HEADING_DAY
        );
    } ## end if ( $day_column )
    out_line $h->th(
        {   out_class(
                $CLASS_GRID_CELL_HEADER,
                $kind eq $HTML_TABLE_HEAD ? $CLASS_GRID_COLUMN_TIME : ()
            )
        },
        $HEADING_TIME
    );

    my @room_ids = room_ids( $region );
    foreach my $idx ( @room_ids ) {
        my $hotel = $rooms{ $idx }->{ $TABLE_HOTEL_ROOM };
        my $name  = $rooms{ $idx }->{ $FIELD_ROOM_NAME };
        if ( $hotel ne $name ) {
            $name = $hotel . $h->br() . $name;
        }
        out_line $h->th(
            {   out_class(
                    $CLASS_GRID_CELL_HEADER, $CLASS_GRID_COLUMN_ROOM,
                    $CLASS_GRID_CELL_ROOM_NAME,
                    $kind eq $HTML_TABLE_HEAD
                    ? ( sprintf $CLASS_GRID_COLUMN_FMT_ROOM_IDX, $idx )
                    : ()
                )
            },
            $name
        );
    } ## end foreach my $idx ( @room_ids)

} ## end sub dump_labels

sub dump_header {
    my ( $region ) = @_;

    out_open $HTML_TABLE, { out_class( $CLASS_GRID_TABLE ) };

    out_open $HTML_COLGROUP;
    if ( $day_column ) {
        out_line $h->col( { out_class( $CLASS_GRID_COLUMN_DAY ) } );
    }
    out_line $h->col( { out_class( $CLASS_GRID_COLUMN_TIME ) } );

    my @room_ids = room_ids( $region );
    foreach my $idx ( @room_ids ) {
        out_line $h->col(
            { out_class( sprintf $CLASS_GRID_COLUMN_FMT_ROOM_IDX, $idx ) } );
    }
    out_close $HTML_COLGROUP;

    out_open $HTML_TABLE_HEAD;
    out_open $HTML_TABLE_ROW, { out_class( $CLASS_GRID_ROW_HEADER ) };
    dump_labels $HTML_TABLE_HEAD, $region;
    out_close $HTML_TABLE_ROW;
    out_close $HTML_TABLE_HEAD;

    out_open $HTML_TABLE_BODY;
} ## end sub dump_header

sub dump_room {
    my ( $region, $guest, $time, $idx, $panel ) = @_;

    if ( !defined $panel ) {
        out_line q{<!--}, $rooms{ $idx }->{ $FIELD_ROOM_NAME }, q{-->},
            $h->td( { out_class( $CLASS_GRID_CELL_EMPTY ) } );
        return;
    }

    my $region_info = $panel->{ $FIELD_BY_REGION }
        ->{ $region->{ $FIELD_START_TIME_SECONDS } } // {};
    if ( $region_info->{ $FIELD_START_TIME_SECONDS } ne $time ) {
        out_line q{<!--}, $rooms{ $idx }->{ $FIELD_ROOM_NAME }, q{ },
            $panel->{ $TABLE_UNIQUE_ID }, q{ continued-->};
        return;
    }

    my $difficulty = $panel->{ $TABLE_DIFFICULTY };
    my $name       = $panel->{ $TABLE_PANEL_NAME };
    my $panelist   = $panel->{ $TABLE_PANELIST };
    my $tokens     = $panel->{ $TABLE_TOKENS };
    my $room       = $rooms{ $idx };

    if ( $panel->{ $FIELD_CAFE } ) {
        $panelist = $name;
        $name     = q{Café featuring};
    }

    my @subclasses = ( q{}, @{ $panel->{ $FIELD_CSS_SUBCLASSES } } );
    if ( $panel->{ $FIELD_GUEST_MAP }->{ $guest } ) {
        push @subclasses, $SUBCLASS_GUEST_PANEL;
    }
    if ( $panel->{ $FIELD_GUEST_CONFLICT }->{ $guest } ) {
        push @subclasses, $SUBCLASS_CONFLICT_PANEL;
    }

    out_line q{<!--}, $rooms{ $idx }->{ $FIELD_ROOM_NAME }, q{-->};
    out_open $HTML_TABLE_DATA,
        {
        id => ( sprintf $ANCHOR_FMT_GRID, $panel->{ $FIELD_CSS_HREF } ),
        rowspan => ( $region_info->{ $FIELD_TABLE_ROWS } // 1 ),
        out_class(
            $CLASS_GRID_COLUMN_ROOM,
            map { sprintf $CLASS_GRID_CELL_FMT_SUBCLASS, $_ } @subclasses
        )
        };

    out_line $h->div(
        {   out_class(
                sprintf $CLASS_GRID_CELL_FMT_SUBCLASS, $SUBCLASS_PIECE_ID
            )
        },
        $panel->{ $TABLE_UNIQUE_ID }
    );
    out_open $HTML_ANCHOR, { href => q{#} . $panel->{ $FIELD_CSS_HREF } };

    if ( $panel->{ $TABLE_FULL } ) {
        out_line $h->div(
            {   out_class(
                    sprintf $CLASS_GRID_CELL_FMT_SUBCLASS,
                    $SUBCLASS_PIECE_FULL
                )
            },
            q{Workshop is Full}
        );
    } ## end if ( $panel->{ $TABLE_FULL...})
    out_line $h->span(
        {   out_class(
                sprintf $CLASS_GRID_CELL_FMT_SUBCLASS,
                $SUBCLASS_PIECE_NAME
            )
        },
        $name
    );

    if ( defined $tokens ) {
        out_line $h->div(
            {   out_class(
                    map { sprintf $CLASS_GRID_CELL_FMT_SUBCLASS, $_ } (
                        $SUBCLASS_PIECE_TOKENS,
                        sprintf $SUBCLASS_PIECE_FMT_TOKENS, $tokens
                    )
                )
            },
            q{Tokens: } . $tokens
        );
    } ## end if ( defined $tokens )

    if ( $panelist =~ m{\S}xms ) {
        out_line $h->span(
            {   out_class(
                    sprintf $CLASS_GRID_CELL_FMT_SUBCLASS,
                    $SUBCLASS_PIECE_PANELIST
                )
            },
            $panelist
        );
    } ## end if ( $panelist =~ m{\S}xms)

    out_close $HTML_ANCHOR;
    out_close $HTML_TABLE_DATA;
} ## end sub dump_room

sub dump_row {
    my ( $region, $guest, $time, $panels_for_timeslot ) = @_;

    my @time_row_classes = $CLASS_GRID_ROW_TIME_SLOT;
    my @time_classes     = (
        $CLASS_GRID_CELL_HEADER, $CLASS_GRID_CELL_TIME_SLOT,
        $CLASS_GRID_COLUMN_TIME
    );

    if (   defined $guest
        && exists $guests{ $guest }
        && $panels_for_timeslot->{ $FIELD_GUEST_MAP }->{ $guest } )
    {
        push @time_row_classes, $CLASS_GRID_ROW_GUEST_BUSY;
        push @time_classes,     $CLASS_GRID_CELL_GUEST_BUSY;
    } ## end if ( defined $guest &&...)

    out_open $HTML_TABLE_ROW, { out_class( @time_row_classes ) };

    if ( $day_column ) {
        out_line $h->th(
            {   out_class(
                    $CLASS_GRID_CELL_HEADER, $CLASS_GRID_CELL_DAY,
                    $CLASS_GRID_COLUMN_DAY
                )
            },
            decode_time( $time, qw{ day } )
        );
        out_line $h->th(
            { out_class( @time_classes ) },
            decode_time( $time, qw{ time } )
        );
    } ## end if ( $day_column )
    else {
        my ( $day, $tm ) = decode_time( $time );
        if (   $region->{ $FIELD_LAST_TIME_OUTPUT } == $time
            || $region->{ $FIELD_DAY_BEING_OUTPUT } ne $day )
        {
            $tm = $day . $h->br() . $tm;
            $region->{ $FIELD_DAY_BEING_OUTPUT } = $day;
        } ## end if ( $region->{ $FIELD_LAST_TIME_OUTPUT...})
        out_line $h->th(
            { out_class( @time_classes ) },
            $tm
        );
    } ## end else [ if ( $day_column ) ]

    my @room_ids = room_ids( $region );
    foreach my $idx ( @room_ids ) {
        dump_room(
            $region, $guest, $time, $idx,
            $panels_for_timeslot->{ $idx }
        );
    } ## end foreach my $idx ( @room_ids)
    out_close $HTML_TABLE_ROW;
} ## end sub dump_row

sub dump_foot {
    my ( $region ) = @_;

    out_close $HTML_TABLE_BODY;
    out_open $HTML_TABLE_FOOT;
    out_open $HTML_TABLE_ROW, { out_class( $CLASS_GRID_ROW_HEADER ) };
    dump_labels $HTML_TABLE_FOOT, $region;
    out_close $HTML_TABLE_ROW;
    out_close $HTML_TABLE_FOOT;
    out_close $HTML_TABLE;
} ## end sub dump_foot

sub dump_region {
    my ( $region, $guest ) = @_;

    dump_header( $region );
    my $rows = $region->{ $FIELD_BY_ROW_SECONDS };
    $region->{ $FIELD_DAY_BEING_OUTPUT } = undef;
    my @times = sort { $a <=> $b } keys %{ $rows };
    $region->{ $FIELD_LAST_TIME_OUTPUT } = $times[ -1 ];
    foreach my $time ( @times ) {
        dump_row( $region, $guest, $time, $rows->{ $time } );
    }
    dump_foot( $region );
} ## end sub dump_region

sub dump_desc_start {
    my ( $region, $guest, $exclude_guest ) = @_;

    if ( exists $guests{ $guest } ) {
        my $hdr_text
            = $exclude_guest
            ? q{Schedule excluding guest panels}
            : q{Schedule for } . $guest;

        if ( $postcard ) {
            out_open $HTML_TABLE, { out_class( $CLASS_DESC_TYPE_TABLE ) };
            out_open $HTML_COLGROUP;
            out_line $h->col( { out_class( $CLASS_DESC_TYPE_COLUMN ) } );
            out_close $HTML_COLGROUP;

            out_line $h->thead(
                { out_class( $CLASS_DESC_TYPE_HEADER ) },
                $h->tr(
                    $h->th(
                        { out_class( $CLASS_DESC_TYPE_COLUMN ) },
                        $hdr_text
                    )
                )
            );
            out_open $HTML_TABLE_BODY;
            out_open $HTML_TABLE_ROW;
            out_open $HTML_TABLE_DATA;
        } ## end if ( $postcard )
        else {
            out_line $h->h2( $hdr_text );
        }
    } ## end if ( exists $guests{ $guest...})

    state $my_idx = 0;
    my $alt_class = $CLASS_DESC_SECTION . ( ++ $my_idx );
    out_open $HTML_DIV, { out_class( $CLASS_DESC_SECTION, $alt_class ) };
} ## end sub dump_desc_start

sub dump_desc_end {
    my ( $region, $guest, $exclude_guest ) = @_;

    out_close $HTML_DIV;

    if ( exists $guests{ $guest } ) {
        if ( $postcard ) {
            out_close $HTML_TABLE_DATA;
            out_close $HTML_TABLE_ROW;
            out_close $HTML_TABLE_BODY;
            out_close $HTML_TABLE;
        } ## end if ( $postcard )
    } ## end if ( exists $guests{ $guest...})
} ## end sub dump_desc_end

sub dump_desc_time_start {
    my ( $region, $guest, $exclude_guest, $time, $busy ) = @_;

    out_open $HTML_TABLE, { out_class( $CLASS_DESC_TIME_TABLE ) };
    out_open $HTML_COLGROUP;
    out_line $h->col( { out_class( $CLASS_DESC_TIME_COLUMN ) } );
    out_close $HTML_COLGROUP;

    my $tm_text = decode_time( $time, qw{ both } );
    if ( $busy ) {
        if ( $exclude_guest ) {
            $tm_text .= q{ Conflict};
        }
        else {
            $tm_text .= q{ Busy};
        }
    } ## end if ( $busy )

    out_line $h->thead(
        { out_class( $CLASS_DESC_TIME_HEADER ) },
        $h->tr(
            $h->th(
                {   out_class(
                        $CLASS_DESC_TIME_COLUMN, $CLASS_DESC_TIME_SLOT
                    )
                },
                $tm_text
            )
        )
    );
    out_open $HTML_TABLE_BODY;
} ## end sub dump_desc_time_start

sub dump_desc_time_end {
    my ( $region, $time ) = @_;

    out_close $HTML_TABLE_BODY;
    out_close $HTML_TABLE;
} ## end sub dump_desc_time_end

sub dump_desc_panel {
    my ($region, $guest, $exclude_guest, $need_time_header_ref, $time,
        $panel,  $busy
    ) = @_;

    return unless $panel->{ $FIELD_START_TIME_SECONDS } == $time;

    my @subclasses = ( q{}, @{ $panel->{ $FIELD_CSS_SUBCLASSES } } );
    my $conflict;

    if ( defined $guest ) {
        if ( $exclude_guest ) {
            if ( $panel->{ $FIELD_GUEST_CONFLICT }->{ $guest } ) {
                push @subclasses, $SUBCLASS_CONFLICT_PANEL;
                $conflict = 1;
            }
            return if $panel->{ $FIELD_GUEST_MAP }->{ $guest };
        } ## end if ( $exclude_guest )
        else {
            return unless $panel->{ $FIELD_GUEST_MAP }->{ $guest };
            push @subclasses, $SUBCLASS_GUEST_PANEL;
        }
    } ## end if ( defined $guest )

    if ( $$need_time_header_ref ) {
        dump_desc_time_start( $region, $guest, $exclude_guest, $time, $busy );
        undef $$need_time_header_ref;
    }

    my $difficulty = $panel->{ $TABLE_DIFFICULTY };
    my $name       = $panel->{ $TABLE_PANEL_NAME };
    my $panelist   = $panel->{ $TABLE_PANELIST };
    my $tokens     = $panel->{ $TABLE_TOKENS };
    my $room       = $panel->{ $FIELD_ROOM_INFO };

    if ( $panel->{ $FIELD_CAFE } ) {
        $name = q{Cosplay Café Featuring } . $name;
    }

    out_open $HTML_TABLE_ROW, { out_class( $CLASS_DESC_PANEL_ROW ) };
    out_open $HTML_TABLE_DATA,
        {
        id => $panel->{ $FIELD_CSS_HREF },
        out_class( map { sprintf $CLASS_DESC_FMT_SUBCLASS, $_ } @subclasses )
        };
    out_line $h->div(
        { out_class( sprintf $CLASS_DESC_FMT_SUBCLASS, $SUBCLASS_PIECE_ID ) },
        $panel->{ $TABLE_UNIQUE_ID }
    );
    out_line $h->a(
        {   href => q{#} . $panel->{ $FIELD_CSS_HREF } . q{Grid},
            out_class(
                sprintf $CLASS_DESC_FMT_SUBCLASS, $SUBCLASS_PIECE_NAME
            )
        },
        $name
    );

    if ( defined $tokens ) {
        out_line $h->div(
            {   out_class(
                    map { sprintf $CLASS_DESC_FMT_SUBCLASS, $_ } (
                        $SUBCLASS_PIECE_TOKENS,
                        sprintf $SUBCLASS_PIECE_FMT_TOKENS, $tokens
                    )
                )
            },
            q{Required tokens: } . $tokens
        );
    } ## end if ( defined $tokens )
    out_line $h->p(
        {   out_class(
                sprintf $CLASS_DESC_FMT_SUBCLASS, $SUBCLASS_PIECE_ROOM
            )
        },
        $room->{ $TABLE_HOTEL_ROOM }
    );
    if ( $panelist =~ m{\S}xms ) {
        out_line $h->p(
            {   out_class(
                    sprintf $CLASS_DESC_FMT_SUBCLASS,
                    $SUBCLASS_PIECE_PANELIST
                )
            },
            $panelist
        );
    } ## end if ( $panelist =~ m{\S}xms)

    my $descbody = $panel->{ $TABLE_DESCRIPTION };
    out_line $h->p(
        {   out_class(
                sprintf $CLASS_DESC_FMT_SUBCLASS, $SUBCLASS_PIECE_DESCRIPTION
            )
        },
        $panel->{ $TABLE_DESCRIPTION }
    );

    my @note;
    if ( $conflict ) {
        push @note, $h->b( q{Conflicts with one of your panels.} );
    }
    if ( defined $panel->{ $TABLE_NOTE } ) {
        push @note, $h->i( $panel->{ $TABLE_NOTE } );
    }
    if ( defined $panel->{ $TABLE_FULL } ) {
        push @note,
            $h->span(
            {   out_class(
                    sprintf $CLASS_DESC_FMT_SUBCLASS, $SUBCLASS_PIECE_FULL
                )
            },
            q{This workshop is full.}
            );
    } ## end if ( defined $panel->{...})
    if ( @note ) {
        out_line $h->p(
            {   out_class(
                    sprintf $CLASS_DESC_FMT_SUBCLASS, $SUBCLASS_PIECE_NOTE
                )
            },
            join q{ },
            @note
        );
    } ## end if ( @note )
    if ( defined $difficulty ) {
        out_line $h->p(
            {   out_class(
                    sprintf $CLASS_DESC_FMT_SUBCLASS,
                    $SUBCLASS_PIECE_DIFFICULTY
                )
            },
            q{Difficulty level: } . $difficulty
        );
    } ## end if ( defined $difficulty)
    out_close $HTML_TABLE_DATA;
    out_close $HTML_TABLE_ROW;
} ## end sub dump_desc_panel

sub dump_desc_region_rows {
    my ( $region, $guest, $exclude_guest ) = @_;
    if ( defined $guest ) {
        undef $guest unless exists $guests{ $guest };
    }
    undef $exclude_guest unless defined $guest;

    my $rows = $region->{ $FIELD_BY_ROW_SECONDS };
    $region->{ $FIELD_DAY_BEING_OUTPUT } = undef;
    my @times = sort { $a <=> $b } keys %{ $rows };
    $region->{ $FIELD_LAST_TIME_OUTPUT } = $times[ -1 ];
DUMP_TIME:
    foreach my $time ( @times ) {
        my $need_time_header    = 1;
        my $panels_for_timeslot = $rows->{ $time };
        my $busy;
        if ( $exclude_guest ) {
            $busy = 1 if has_guest( $panels_for_timeslot, $guest );
        }
        foreach my $idx ( @all_room_ids ) {
            my $panel = $panels_for_timeslot->{ $idx };
            next unless defined $panel;
            dump_desc_panel(
                $region, $guest, $exclude_guest,
                \$need_time_header, $time, $panel, $busy
            );
        } ## end foreach my $idx ( @all_room_ids)
        unless ( $need_time_header ) {
            dump_desc_time_end( $region, $time );
        }
    } ## end DUMP_TIME: foreach my $time ( @times )
} ## end sub dump_desc_region_rows

sub dump_desc_region {
    my ( $region, $guest ) = @_;

    dump_desc_start( $region, $guest );
    dump_desc_region_rows( $region, $guest );
    dump_desc_end( $region, $guest );

    if ( exists $guests{ $guest } && !$just_guest ) {
        dump_desc_start( $region, $guest, 1 );
        dump_desc_region_rows( $region, $guest, 1 );
        dump_desc_end( $region, $guest, 1 );
    }
} ## end sub dump_desc_region

sub dump_desc_all_regions {
    my ( $guest, $exclude_guest ) = @_;

    dump_desc_start( undef, $guest, $exclude_guest );
    foreach my $region_time ( sort { $a <=> $b } keys %time_region ) {
        my $region = $time_region{ $region_time };
        dump_desc_region_rows( $region, $guest, $exclude_guest );
    }
    dump_desc_end( undef, $guest, $exclude_guest );
} ## end sub dump_desc_all_regions

sub cache_inline_style {
    my ( $file ) = @_;
    return unless defined $file;
    state %cache;
    return $cache{ $file } //= read_file(
        $file,
        { chomp => 1, array_ref => 1, err_mode => q{carp} }
    );
} ## end sub cache_inline_style

sub dump_tables {
    my ( $guest ) = @_;
    my $guest_file = $guests{ $guest };
    undef $guest unless defined $guest_file;

    my %time_points = map { $_ => 1 } ( keys %time_region );
    my $ofname = $oname;

    if ( $oname eq q{-} ) {
        $ofname = q{<STDOUT>};
        $ofh    = \*STDOUT;
    }
    else {
        if ( -d $oname ) {
            $ofname = File::Spec->catfile(
                $oname,
                ( $guest_file || q{index} ) . q{.html}
            );
        } ## end if ( -d $oname )
        elsif ( $guest_file ) {
            $ofname = $oname . q{.} . $guest_file . q{.html};
        }
        open $ofh, q{>:encoding(utf8)}, $ofname
            or die qq{Unable to write: ${ofname}\n};
    } ## end else [ if ( $oname eq q{-} ) ]

    say { $ofh } q{<!doctype html>};
    out_open $HTML_HTML;
    out_open $HTML_HEAD;
    out_line $h->meta( { charset => q{UTF-8} } );
    out_line $h->meta(
        { name => q{apple-mobile-web-app-capable}, content => q{yes} } );
    out_line $h->title( q{Cosplay America 2019 Schedule} );
    out_line $h->link(
        {   href =>
                q{https://fonts.googleapis.com/css?family=Nunito+Sans&display=swap},
            rel => q{stylesheet}
        }
    );

    my $is_in_styles;
    my $open_styles = sub {
        return if $is_in_styles;
        out_open $HTML_STYLE;
        $is_in_styles = 1;
    };
    my $close_styles = sub {
        return unless $is_in_styles;
        out_close $HTML_STYLE;
        undef $is_in_styles;
    };
    foreach my $style ( @styles ) {
        my $is_html = $style =~ m{.html?\z}xms;
        my $lines;
        if ( $inline_css || $is_html ) {
            $lines = cache_inline_style( $style );
        }
        if ( $lines ) {
            if ( $is_html ) {
                $close_styles->();
            }
            else {
                $open_styles->();
            }
            foreach my $line ( @{ $lines } ) {
                out_line $line;
            }
        } ## end if ( $lines )
        elsif ( !$is_html ) {
            $close_styles->();
            out_line $h->link(
                { href => $style, rel => q{stylesheet}, type => q{text/css} }
            );
        } ## end elsif ( !$is_html )
    } ## end foreach my $style ( @styles)
    $close_styles->();

    out_close $HTML_HEAD;
    out_open $HTML_BODY;

    if ( $show_grid ) {
        foreach my $region_time ( sort { $a <=> $b } keys %time_region ) {
            my $region = $time_region{ $region_time };
            dump_region( $region, $guest );
            if ( $show_descriptions && !$separate_desc ) {
                dump_desc_region( $region, $guest );
            }
        } ## end foreach my $region_time ( sort...)
    } ## end if ( $show_grid )

    if ( $show_descriptions && ( $separate_desc || !$show_grid ) ) {
        dump_desc_all_regions( $guest );
        if ( exists $guests{ $guest } && !$just_guest ) {
            dump_desc_all_regions( $guest, 1 );
        }
    } ## end if ( $show_descriptions...)

    out_close $HTML_BODY;
    out_close $HTML_HTML;

    if ( $oname ne q{-} ) {
        $ofh->close
            or die qq{Unable to close $ofname: $!\n};
    }
    undef $ofh;
} ## end sub dump_tables

sub main {
    my ( @args ) = @_;

    GetOptionsFromArray(
        \@args,
        q{input=s}       => \$fname,
        q{output=s}      => \$oname,
        q{day!}          => \$day_column,
        q{unified!}      => \$unified,
        q{perday!}       => \$perday,
        q{separate!}     => \$separate_desc,
        q{style=s@}      => \@styles,
        q{inline_css!}   => \$inline_css,
        q{guests!}       => \$split_guest,
        q{postcard!}     => \$postcard,
        q{justguest!}    => \$just_guest,
        q{hideunused!}   => \$hide_unused,
        q{grid!}         => \$show_grid,
        q{descriptions!} => \$show_descriptions,
    ) or die qq{Usage: desc_tbl -input [file] -output [file]\n};

    $inline_css //= 1 if @styles;
    push @styles, qw{ index.css } unless @styles;

    $show_grid         //= 0 if $show_descriptions;
    $show_descriptions //= 0 if $show_grid;
    $show_grid         //= 1;
    $show_descriptions //= 1;

    $fname //= shift @args;
    $oname //= shift @args;
    $oname //= q{-};

    read_csv_file( $fname );

    make_time_ranges;

    $split_guest //= 1 if $just_guest;

    if ( $split_guest ) {
        foreach my $guest ( keys %guests ) {
            dump_tables( $guest );
        }
    }
    dump_tables;
} ## end sub main

main( @ARGV );

1;
